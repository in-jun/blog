+++
title = '1차 캐시와 2차 캐시 알아보기'
date = 2024-06-08T03:39:05+09:00
tags = ["ORM", "java"]
categories = ["programming"]
draft = false
+++

### 1차 캐시(First Level Cache)란

**1차 캐시(First Level Cache)** 는 영속성 컨텍스트(Persistence Context) 내부에 존재하는 캐시를 말한다. 1차 캐시는 엔티티를 조회하면, 영속성 컨텍스트가 엔티티를 캐시에 저장한다. 이후 같은 엔티티를 조회하면, 영속성 컨텍스트는 캐시에서 엔티티를 찾아 반환한다.

그렇기 때문에 트랜잭션 내에서만 유효하며, 트랜잭션이 종료되면 1차 캐시도 함께 종료된다.

#### 더티 체킹(Dirty Checking)

**더티 체킹(Dirty Checking)**은 1차 캐시를 통해 엔티티의 변경 사항을 추적하는 방식이다. 엔티티를 조회하면, 영속성 컨텍스트는 엔티티의 초기 상태를 저장한다. 이후 엔티티의 상태가 변경되면, 영속성 컨텍스트는 변경 사항을 추적하고 데이터베이스에 반영한다.

### 2차 캐시(Second Level Cache)란

**2차 캐시(Second Level Cache)** 는 여러 영속성 컨텍스트 간에 공유되는 캐시를 말한다. 2차 캐시는 영속성 컨텍스트가 종료되어도 캐시가 유지되며, 여러 영속성 컨텍스트 간에 엔티티를 공유할 수 있다.

그렇기 때문에 2차 캐시는 여러 트랜잭션 간에 유효하다.

> 2차 캐시는 동시성 문제를 유발할 수 있다. 따라서 객체를 직접 제공하는 것이 아니라 복사본을 제공하거나 락을 이용하여 동시성 문제를 제어해야 한다.

#### 사용 방법

2차 캐시를 사용하려면, `@Cacheable` 애노테이션을 사용하여 엔티티를 캐시할 수 있다. 또한 `@Cache` 애노테이션을 사용하여 캐시의 설정을 변경할 수 있다.

```java
@Entity
@Cacheable
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Member {
    ...
}
```

### 캐시 동작 방식

1. **조회 시 캐시 검색**:

    - 엔티티를 조회하면, 영속성 컨텍스트는 1차 캐시에서 엔티티를 찾는다.
    - 1차 캐시에 엔티티가 없으면, 2차 캐시에서 엔티티를 찾는다.
    - 2차 캐시에 엔티티가 없으면, 데이터베이스에서 엔티티를 조회하고 1차 캐시와 2차 캐시에 저장한다.

2. **캐시 저장**:

    - 엔티티를 조회하면, 영속성 컨텍스트는 엔티티를 1차 캐시에 저장한다.
    - 1차 캐시에 저장된 엔티티는 트랜잭션이 종료되기 전까지 유효하다.
    - 2차 캐시에 저장된 엔티티는 영속성 컨텍스트가 종료되어도 유효하다.

3. **캐시 갱신**:

    - 엔티티를 수정하면, 영속성 컨텍스트는 1차 캐시와 2차 캐시의 엔티티를 갱신한다.
    - 1차 캐시와 2차 캐시에 저장된 엔티티는 변경 사항이 자동으로 반영된다.

### 결론

데이터베이스 조회를 최소화하고 성능을 향상하기 위해, 1차 캐시와 2차 캐시를 적절히 활용하는 것이 중요하다. 1차 캐시는 트랜잭션 내에서만 유효하며, 2차 캐시는 여러 트랜잭션 간에 유효하다. 따라서 1차 캐시와 2차 캐시를 적절히 조합하여 성능 최적화를 수행할 수 있다.
