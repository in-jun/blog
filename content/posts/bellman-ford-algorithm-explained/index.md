---
title: "벨만-포드(Bellman-Ford) 알고리즘 알아보기"
date: 2024-06-17T18:40:50+09:00
tags: ["벨만-포드", "Bellman-Ford", "알고리즘", "최단 경로"]
description: "벨만-포드(Bellman-Ford) 알고리즘은 Richard Bellman(1958)과 Lester Ford(1956)에 의해 독립적으로 발견된 단일 시작점 최단 경로 알고리즘으로, 다익스트라 알고리즘과 달리 음수 가중치를 가진 간선을 처리할 수 있으며, 동적 프로그래밍 접근법을 사용하여 O(VE) 시간 복잡도로 최단 경로를 찾고, 음수 사이클의 존재 여부를 탐지할 수 있어 네트워크 라우팅, 화폐 환율 변환, 차익 거래 탐지 등 다양한 실제 응용 분야에서 활용되는 핵심 그래프 알고리즘이다."
draft: false
---

## 벨만-포드 알고리즘

벨만-포드(Bellman-Ford) 알고리즘은 가중치 그래프에서 단일 시작점으로부터 다른 모든 정점까지의 최단 경로를 찾는 알고리즘으로, 다익스트라 알고리즘과 유사하지만 음수 가중치를 가진 간선이 있는 그래프에서도 정확하게 동작하며, 추가적으로 그래프 내에 음수 사이클이 존재하는지 여부를 탐지할 수 있는 강력한 기능을 제공한다.

### 벨만-포드 알고리즘의 역사

벨만-포드 알고리즘은 Richard Bellman이 1958년에 발표한 논문과 Lester Ford가 1956년에 발표한 연구에서 독립적으로 발견된 알고리즘으로, 두 연구자의 이름을 따서 벨만-포드 알고리즘이라고 명명되었으며, 이 알고리즘은 동적 프로그래밍(Dynamic Programming) 접근법을 사용하여 최단 경로 문제를 해결한다는 점에서 중요한 의미를 가진다. Richard Bellman은 동적 프로그래밍의 창시자로서 최적화 문제를 작은 하위 문제로 분할하여 해결하는 방법론을 제시했고, 벨만-포드 알고리즘은 이러한 동적 프로그래밍 원리를 그래프의 최단 경로 문제에 적용한 대표적인 사례다.

이 알고리즘은 네트워크 흐름 이론과 라우팅 프로토콜 개발에 큰 영향을 미쳤으며, 특히 RIP(Routing Information Protocol)와 같은 거리 벡터 라우팅 프로토콜의 이론적 기반이 되었고, 인터넷의 초기 라우팅 메커니즘 설계에 중요한 역할을 했다. 또한 음수 가중치를 처리할 수 있다는 특성 덕분에 금융 시장에서의 차익 거래(arbitrage) 탐지, 화폐 환율 변환 문제, 그리고 다양한 최적화 문제에서 실용적으로 활용되고 있다.

### 알고리즘 동작 원리

벨만-포드 알고리즘의 핵심 동작 원리는 간선 완화(Edge Relaxation)를 모든 간선에 대해 V-1번 반복하는 것이며, 여기서 V는 그래프의 정점 개수를 의미하고, 간선 완화란 현재 알고 있는 최단 거리보다 더 짧은 경로를 발견했을 때 거리 정보를 갱신하는 과정을 말한다.

#### 간선 완화(Edge Relaxation) 개념

간선 완화는 정점 u에서 정점 v로 가는 간선 (u, v)의 가중치를 w라고 할 때, 만약 dist[u] + w < dist[v]라면 dist[v]를 dist[u] + w로 갱신하는 과정이며, 이는 u를 경유하여 v로 가는 경로가 현재 알고 있는 v까지의 최단 경로보다 더 짧다는 것을 의미하고, 따라서 더 나은 경로로 갱신하는 것이다.

#### V-1번 반복하는 이유

그래프에서 최단 경로는 최대 V-1개의 간선을 포함할 수 있으며, 이는 시작 정점에서 출발하여 다른 정점으로 가는 경로가 사이클을 포함하지 않는 단순 경로(simple path)일 때 최대 V-1개의 간선으로 구성될 수 있기 때문이다. 만약 경로가 V개 이상의 간선을 포함한다면 반드시 같은 정점을 두 번 이상 방문하게 되어 사이클이 존재하게 되고, 음수 사이클이 아닌 일반적인 경우에는 사이클을 제거한 더 짧은 경로가 존재하므로 최단 경로가 될 수 없다.

따라서 첫 번째 반복에서는 시작 정점에서 1개의 간선으로 도달할 수 있는 정점들의 최단 거리가 확정되고, 두 번째 반복에서는 2개의 간선으로 도달할 수 있는 정점들의 최단 거리가 확정되며, 이러한 방식으로 V-1번 반복하면 최대 V-1개의 간선을 포함하는 모든 최단 경로가 확정된다. 이것이 바로 동적 프로그래밍의 핵심 원리로, 작은 하위 문제(더 적은 간선을 사용하는 최단 경로)의 해를 이용하여 더 큰 문제(더 많은 간선을 사용하는 최단 경로)를 해결하는 방식이다.

### 알고리즘 수행 순서

1. 시작 정점에서 각 정점까지의 거리를 저장하는 배열을 초기화하고, 시작 정점의 거리는 0으로 설정하며, 다른 모든 정점의 거리는 무한대(INF)로 초기화한다.

2. 모든 간선에 대해 간선 완화를 수행하며, 이 과정을 정점의 개수에서 1을 뺀 만큼(V-1번) 반복한다.

3. 각 간선 (u, v)에 대해 dist[u] + weight(u, v) < dist[v]인 경우 dist[v]를 dist[u] + weight(u, v)로 갱신한다.

4. V-1번의 반복이 끝난 후, 모든 간선에 대해 한 번 더 완화를 시도하여 음수 사이클의 존재 여부를 확인한다.

5. 만약 V번째 반복에서 거리가 갱신되는 간선이 있다면 그래프에 음수 사이클이 존재하는 것이며, 이 경우 최단 경로가 정의되지 않는다.

### 예제 코드

```cpp
#include <iostream>
#include <vector>
using std::cin;
using std::cout;
using std::pair;
using std::vector;

#define INF 1000000000

int main()
{
    int n, m;
    cin >> n >> m;

    vector<vector<pair<int, int>>> graph(n + 1);
    vector<int> dist(n + 1, INF);

    for (int i = 0; i < m; i++)
    {
        int u, v, w;
        cin >> u >> v >> w;
        graph[u].push_back({v, w});
    }

    int start;
    cin >> start;

    dist[start] = 0;

    for (int i = 0; i < n - 1; i++)
    {
        for (int u = 1; u <= n; u++)
        {
            for (auto p : graph[u])
            {
                int v = p.first;
                int w = p.second;

                if (dist[u] != INF && dist[v] > dist[u] + w)
                {
                    dist[v] = dist[u] + w;
                }
            }
        }
    }

    for (int u = 1; u <= n; u++)
    {
        for (auto p : graph[u])
        {
            int v = p.first;
            int w = p.second;

            if (dist[u] != INF && dist[v] > dist[u] + w)
            {
                cout << "음수 사이클이 존재합니다.\n";
                return 0;
            }
        }
    }

    for (int i = 1; i <= n; i++)
    {
        if (dist[i] == INF)
        {
            cout << "INF\n";
        }
        else
        {
            cout << dist[i] << '\n';
        }
    }

    return 0;
}
```

### 음수 가중치 처리

벨만-포드 알고리즘의 가장 큰 특징은 음수 가중치를 가진 간선을 올바르게 처리할 수 있다는 점이며, 이는 다익스트라 알고리즘과 가장 큰 차이점이다.

#### 다익스트라 알고리즘의 한계

다익스트라 알고리즘은 탐욕적(greedy) 접근법을 사용하여 매번 현재까지 발견된 최단 거리를 가진 정점을 선택하고 그 정점의 최단 거리를 확정하는데, 이는 한 번 확정된 정점의 최단 거리는 더 이상 갱신되지 않는다는 것을 전제로 하며, 모든 간선의 가중치가 양수일 때는 이 전제가 성립하지만 음수 가중치가 있으면 이미 확정된 정점을 거쳐서 더 짧은 경로가 나중에 발견될 수 있어 알고리즘이 올바르게 동작하지 않는다.

#### 벨만-포드의 음수 가중치 처리 원리

벨만-포드 알고리즘은 모든 정점의 최단 거리를 동시에 갱신하는 방식을 사용하며, 정점을 확정하는 개념이 없이 V-1번의 반복을 통해 모든 간선에 대한 완화를 반복적으로 수행하므로, 음수 가중치로 인해 나중에 더 짧은 경로가 발견되더라도 다음 반복에서 거리가 갱신될 수 있어 정확한 최단 거리를 찾을 수 있다. 이러한 특성 덕분에 간선의 가중치가 음수이더라도 음수 사이클만 존재하지 않는다면 올바른 최단 경로를 계산할 수 있다.

#### 음수 가중치의 실제 응용 사례

음수 가중치는 실제 문제에서 다양하게 등장하는데, 화폐 환율 변환 문제에서 환율을 로그 변환하면 곱셈이 덧셈으로 바뀌고 환차익은 음수 사이클로 표현되며, 네트워크 흐름 문제에서는 비용을 최소화하기 위해 음수 비용 간선을 사용할 수 있고, 게임 이론이나 최적화 문제에서도 손실을 나타내기 위해 음수 가중치가 자연스럽게 모델링된다.

### 음수 사이클 탐지

음수 사이클(negative cycle)은 사이클을 구성하는 간선들의 가중치 합이 음수인 사이클을 의미하며, 음수 사이클이 존재하면 그 사이클을 계속 돌면서 거리를 무한히 줄일 수 있기 때문에 최단 경로가 정의되지 않는다.

#### 음수 사이클의 의미

음수 사이클이 있으면 해당 사이클에 포함된 정점들은 사이클을 한 번 돌 때마다 거리가 감소하므로 이론적으로 사이클을 무한히 반복하면 거리를 음의 무한대로 만들 수 있고, 따라서 명확한 최단 거리를 정의할 수 없으며, 이는 실제 문제에서 차익 거래 기회가 존재하거나 모델링에 오류가 있음을 의미할 수 있다.

#### V번째 반복으로 음수 사이클 탐지

벨만-포드 알고리즘에서 V-1번의 반복으로 모든 최단 경로가 확정되어야 하므로, V번째 반복에서 여전히 거리가 갱신되는 간선이 있다면 이는 V개 이상의 간선을 사용하는 경로가 더 짧다는 의미이며, 이는 사이클을 포함하면서 거리가 감소하는 음수 사이클이 존재한다는 증거다. 따라서 알고리즘의 마지막에 모든 간선을 한 번 더 검사하여 거리가 갱신되는지 확인함으로써 음수 사이클의 존재 여부를 판별할 수 있다.

#### 음수 사이클이 있을 때의 처리

음수 사이클이 탐지되면 최단 경로가 정의되지 않으므로 일반적으로 알고리즘을 종료하고 음수 사이클이 존재함을 보고하며, 만약 음수 사이클에 도달할 수 없는 정점들이 있다면 그 정점들에 대해서는 최단 거리가 유효할 수 있지만, 대부분의 응용에서는 음수 사이클의 존재 자체가 문제 상황을 나타내므로 별도의 처리가 필요하다.

### 시간 복잡도 분석

벨만-포드 알고리즘의 시간 복잡도는 O(VE)로 표현되며, 여기서 V는 정점의 개수이고 E는 간선의 개수다.

#### O(VE) 상세 분석

알고리즘은 V-1번의 외부 반복을 수행하고, 각 반복마다 모든 E개의 간선에 대해 완화를 시도하므로 총 연산 횟수는 (V-1) × E가 되며, 여기에 음수 사이클 검사를 위한 E번의 추가 연산이 필요하지만 이는 점근적으로 O(VE) 시간 복잡도에 포함된다. 각 간선 완화는 상수 시간 O(1)에 수행되므로 전체 알고리즘의 시간 복잡도는 O(VE)가 된다.

#### 최악의 경우 분석

그래프가 밀집 그래프(dense graph)인 경우 간선의 개수 E는 O(V²)가 될 수 있으며, 이 경우 벨만-포드 알고리즘의 시간 복잡도는 O(V × V²) = O(V³)가 되어 매우 느려진다. 반면 희소 그래프(sparse graph)에서는 E = O(V)이므로 시간 복잡도가 O(V²)로 개선되며, 실제로는 조기 종료 최적화를 통해 평균적으로 더 빠르게 동작할 수 있다.

#### 다익스트라와의 시간 복잡도 비교

다익스트라 알고리즘은 우선순위 큐를 사용하는 구현에서 O((V+E) log V)의 시간 복잡도를 가지며, 밀집 그래프에서는 O(V² log V), 희소 그래프에서는 O(E log V)가 되어 일반적으로 벨만-포드보다 훨씬 빠르다. 하지만 다익스트라는 음수 가중치를 처리할 수 없으므로, 음수 가중치가 없고 속도가 중요한 경우에는 다익스트라를, 음수 가중치가 있거나 음수 사이클 탐지가 필요한 경우에는 벨만-포드를 사용해야 한다.

### 다익스트라 알고리즘과의 비교

벨만-포드와 다익스트라는 모두 단일 시작점 최단 경로 문제를 해결하지만 접근 방식과 적용 가능한 상황에서 차이가 있다.

#### 속도 차이

다익스트라 알고리즘은 O((V+E) log V)로 벨만-포드의 O(VE)보다 일반적으로 훨씬 빠르며, 특히 대규모 그래프에서 성능 차이가 크게 나타나고, 이는 다익스트라가 탐욕적 접근으로 각 정점을 한 번만 처리하는 반면 벨만-포드는 모든 간선을 V-1번 반복 검사하기 때문이다.

#### 음수 가중치 처리

다익스트라는 모든 간선의 가중치가 0 이상이어야 하지만 벨만-포드는 음수 가중치를 처리할 수 있으며, 이것이 가장 중요한 차이점으로 문제에 음수 가중치가 있다면 벨만-포드를 사용해야 한다.

#### 구현 복잡도

벨만-포드는 3중 루프만으로 구현할 수 있어 코드가 단순하고 이해하기 쉬운 반면, 다익스트라는 우선순위 큐나 힙 자료구조를 사용해야 하므로 구현이 상대적으로 복잡하며, 교육 목적이나 간단한 응용에서는 벨만-포드가 더 적합할 수 있다.

#### 사용 시나리오

다익스트라는 도로 네트워크, GPS 내비게이션, 네트워크 패킷 라우팅 등 대부분의 실제 응용에서 사용되며, 벨만-포드는 화폐 환율, 차익 거래 탐지, 음수 비용 흐름 문제, 그리고 음수 사이클 탐지가 필요한 특수한 경우에 사용된다.

### 실제 응용 사례

벨만-포드 알고리즘은 다양한 실제 문제에서 핵심적인 역할을 하며, 특히 음수 가중치나 음수 사이클 탐지가 필요한 영역에서 필수적이다.

#### 네트워크 라우팅 프로토콜

RIP(Routing Information Protocol)는 벨만-포드 알고리즘을 기반으로 한 거리 벡터 라우팅 프로토콜로, 각 라우터가 주기적으로 자신의 라우팅 테이블을 이웃 라우터와 교환하며 최단 경로를 계산하고, 인터넷의 초기 라우팅 시스템에서 널리 사용되었으며 현재도 소규모 네트워크에서 활용되고 있다.

#### 차익 거래 탐지

금융 시장에서 여러 화폐 간의 환율을 그래프로 모델링할 때, 환율의 로그 값을 간선 가중치로 사용하면 환전 과정이 덧셈으로 표현되고, 만약 음수 사이클이 존재한다면 이는 차익 거래(arbitrage) 기회가 있음을 의미하므로, 벨만-포드 알고리즘으로 음수 사이클을 탐지하여 무위험 수익 기회를 찾을 수 있다.

#### 화폐 환율 변환

여러 화폐 간의 최적 환전 경로를 찾을 때 벨만-포드 알고리즘을 사용할 수 있으며, 각 환전에는 수수료가 있고 환율이 시간에 따라 변하는 상황에서도 최적 경로를 계산할 수 있고, 음수 가중치를 통해 프로모션이나 리베이트를 모델링할 수도 있다.

#### 최소 비용 흐름 문제

네트워크 흐름 문제에서 각 간선에 용량뿐만 아니라 비용이 있을 때, 최소 비용으로 최대 흐름을 보내는 문제를 해결하는 알고리즘들은 벨만-포드를 내부적으로 사용하며, 이는 물류, 운송, 통신 네트워크 최적화 등에 응용된다.

### 최적화 기법

벨만-포드 알고리즘의 기본 형태는 항상 V-1번의 완전한 반복을 수행하지만, 실제로는 더 빠르게 수렴하도록 여러 최적화 기법을 적용할 수 있다.

#### 조기 종료 최적화

특정 반복에서 어떤 간선도 완화되지 않았다면 이미 모든 최단 거리가 확정된 것이므로 남은 반복을 건너뛰고 알고리즘을 종료할 수 있으며, 이는 실제로 많은 경우 V-1번보다 훨씬 적은 반복으로 최단 경로를 찾을 수 있게 하고, 평균 성능을 크게 향상시킨다.

#### SPFA(Shortest Path Faster Algorithm)

SPFA는 벨만-포드 알고리즘의 최적화된 변형으로, 큐(Queue) 자료구조를 사용하여 거리가 갱신된 정점만을 선택적으로 처리하는 방식이며, 모든 간선을 반복적으로 검사하는 대신 거리가 변경된 정점의 인접 간선만 완화하므로 평균적으로 O(E) 시간에 동작하고, 최악의 경우에도 O(VE)를 넘지 않아 실용적으로 많이 사용된다.

#### 큐를 이용한 개선

큐에 시작 정점을 넣고 큐에서 정점을 하나씩 꺼내면서 그 정점에서 출발하는 간선들을 완화하며, 간선 완화로 거리가 갱신된 정점은 큐에 다시 추가하는 방식으로 동작하고, 이미 큐에 있는 정점은 중복 추가를 방지하여 효율성을 높이며, 이 방법은 실제로 많은 경우 다익스트라와 비슷한 성능을 보이면서도 음수 가중치를 처리할 수 있다.

### 정리

벨만-포드 알고리즘은 음수 가중치를 처리할 수 있고 음수 사이클을 탐지할 수 있다는 점에서 다익스트라 알고리즘과 차별화되며, 비록 O(VE)의 시간 복잡도로 일반적인 경우 다익스트라보다 느리지만 특정 문제 영역에서는 대체 불가능한 중요한 알고리즘이다. 동적 프로그래밍의 원리를 그래프 문제에 적용한 대표적인 사례로서 알고리즘 설계의 중요한 개념을 학습할 수 있으며, 네트워크 라우팅, 금융 공학, 최적화 문제 등 다양한 실제 응용 분야에서 핵심적인 역할을 한다.
