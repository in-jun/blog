---
title: "Dirty Checking 알아보기"
date: 2024-06-08T02:47:28+09:00
tags: ["ORM", "java"]
description: "JPA Dirty Checking의 스냅샷 비교 동작 원리, flush 시점과의 관계, @DynamicUpdate의 역할과 성능 영향, 준영속 상태에서 작동하지 않는 경우, 대량 업데이트 성능 최적화 방법까지 정리"
draft: false
---

## Dirty Checking이란

Dirty Checking은 JPA에서 엔티티의 변경 사항을 자동으로 감지하고 이를 데이터베이스에 반영하는 방식이다.

### 자동 변경 감지

개발자가 명시적으로 데이터베이스 업데이트 쿼리를 작성할 필요 없이 객체의 상태만 변경하면 자동으로 UPDATE 쿼리가 생성되고 실행된다.

### 적용 대상

Dirty Checking은 영속성 컨텍스트가 관리하는 엔티티에만 적용된다.

- 준영속 상태나 비영속 상태의 엔티티는 변경 감지 대상이 아님

## 변경 감지의 동작 원리

### 스냅샷 생성

엔티티가 로딩될 때마다 Hibernate는 모든 엔티티 속성값을 가지고 있는 스냅샷, 즉 복사본을 생성한다.

### 비교와 업데이트

flush가 일어나는 시점에 엔티티와 스냅샷을 비교하여 변경된 부분을 체크하고 업데이트한다.

#### 구체적인 동작 과정

1. EntityManager가 엔티티를 관리할 때 영속성 컨텍스트가 엔티티의 초기 상태를 저장
2. Hibernate는 엔티티 조회 시에 조회한 엔티티의 복제본을 저장
3. 이후에 equals로 각 필드를 비교해서 변경 감지를 수행

### Flush 시점의 동작

Transaction.commit()을 하면 flush()가 일어날 때 다음 과정을 거친다.

1. 엔티티와 스냅샷을 일일이 비교
2. 변경사항이 있으면 UPDATE 쿼리를 만들어 쓰기 지연 SQL 저장소에 넣음
3. 데이터베이스에 반영하고 커밋

### 적용 대상

상태 변경 검사의 대상은 영속성 컨텍스트가 관리하는 엔티티에만 적용된다.

- 준영속 상태나 비영속 상태는 Dirty Checking의 대상이 아님

## flush 시점과 Dirty Checking

### flush의 역할

flush가 발생할 때 JPA는 변경을 감지하고 수정된 엔티티를 쓰기 지연 SQL 저장소에 등록한다.

1. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송
2. flush가 발생한다고 해서 commit이 이루어지는 것이 아님
3. flush 다음에 실제 commit이 일어남

### flush 발생 시점

flush는 다음 시점에 발생한다.

- **Transaction Commit**: 트랜잭션을 커밋하면 엔티티 매니저 내부에서 먼저 flush가 호출
- **EntityManager Flush**: 명시적으로 flush() 메서드 호출
- **JPQL 사용**: JPQL 쿼리 실행 시점

### flush의 필요성

트랜잭션 커밋 시 flush()가 자동 호출되는 이유는 SQL을 쓰지 않고 COMMIT을 수행한다면 어떤 일도 일어나지 않기 때문이다.

트랜잭션이 시작되고 해당 트랜잭션이 commit 되는 시점 직전에만 동기화하면 된다. 그 사이에서 flush 메커니즘의 동작이 가능하다.

## @DynamicUpdate의 역할과 성능 영향

### JPA의 기본 동작

JPA는 수정 쿼리가 항상 동일하게 만들어지도록 기본적으로 모든 필드를 업데이트한다.

#### 장점

- 부트 실행 시점에 미리 UPDATE 쿼리를 만들어서 재사용이 가능
- 데이터베이스에서도 이전에 파싱된 쿼리의 재사용이 가능

### @DynamicUpdate 사용

@DynamicUpdate 어노테이션을 엔티티 클래스에 적용하면 Hibernate는 값이 수정된 컬럼만 포함하는 SQL UPDATE 문을 생성한다.

#### 동작 방식

현재 상태와 수정된 상태를 비교하여 변경된 컬럼만 찾아낸다.

#### 성능 영향

@DynamicUpdate를 사용할 때는 Hibernate가 캐시된 SQL 문을 사용하지 않고 매번 새로운 SQL 문을 생성한다.

- 런타임에 변경 추적과 쿼리 생성 비용이 발생

### 사용 권장 사례

수십 개의 필드를 가진 엔티티의 경우 @DynamicUpdate는 다음과 같은 이점이 있다.

- 수정되지 않은 엔티티 컬럼의 직렬화, 전송, 역직렬화에 대한 네트워크, CPU 및 기타 리소스 낭비를 방지
- 컬럼 수준 잠금을 사용하는 데이터베이스에서는 필드가 적은 엔티티에도 큰 효과

#### 특별한 경우

- JSON 속성을 포함하는 엔티티
- MVCC 데이터베이스에서 컬럼 수준 버저닝을 사용하는 경우

## Dirty Checking이 작동하지 않는 경우

### 영속성 컨텍스트 관리 대상

Dirty Checking은 영속성 컨텍스트에서 관리되는 엔티티에만 작동한다.

준영속 상태나 비영속 상태의 엔티티는 변경 감지 대상에서 제외된다.

### 준영속 상태

준영속 상태는 영속성 컨텍스트로부터 분리된 상태를 의미한다.

- detach된 준영속 상태
- 데이터베이스에 아직 반영되지 않은 엔티티처럼 비영속 상태
- Dirty Checking이 수행되지 않고 값을 변경해도 데이터베이스에 반영되지 않음

### 영속성 컨텍스트의 필요성

영속성 컨텍스트가 제공하는 기능인 Dirty Checking과 업데이트 쿼리 발행 등을 사용하려면 엔티티가 영속성 컨텍스트에서 관리되어야 한다.

JPA에서는 엔티티를 조회할 시 해당 엔티티의 스냅샷을 찍어놓는다. 이 스냅샷과 비교해 트랜잭션 종료 시 변경된 사항이 있다면 UPDATE 쿼리를 데이터베이스에 요청한다.

## 대량 업데이트 시 성능 최적화

### JDBC 배치 설정

JDBC 배치를 활성화하려면 다음 설정이 필요하다.

- `spring.jpa.properties.hibernate.jdbc.batch_size` 설정
- `spring.jpa.properties.hibernate.order_updates`를 true로 설정

문장을 정렬하면 Hibernate가 제공된 바인드 파라미터 값만 다른 동일한 모든 UPDATE 문을 순차적으로 실행하도록 보장한다.

### 낙관적 잠금 사용 시

@Version 어노테이션을 사용하는 낙관적 잠금을 사용할 때는 `hibernate.jdbc.batch_versioned_data` 속성을 true로 설정한다.

배치 업데이트 실행 후 반환된 개수와 변경된 엔티티 개수를 비교할 수 있다.

### 사용자 정의 수정 쿼리

모든 필요한 변경을 수행하는 UPDATE 문을 정의할 수 있다면 다음 방법이 더 좋다.

- @Query와 @Modifying 어노테이션을 사용하여 Repository에 사용자 정의 수정 쿼리를 정의

#### 최적화 전략

상태 기준으로 데이터를 그룹화하고 ID를 통해 업데이트하면 청크당 최대 2번의 데이터베이스 통신만 필요하다. 네트워크 I/O를 크게 줄일 수 있다.

### 배치 애플리케이션 최적화

대규모 처리를 하는 배치 애플리케이션의 경우 다음을 권장한다.

- 엔티티 객체 대신 Projection 객체를 반환하는 것이 권장됨
- 매우 큰 데이터 볼륨의 경우 Spring Data JDBC의 batchUpdate()를 사용하는 것이 권장됨
- Spring Data JPA와 함께 사용할 수 있음

## 결론

Dirty Checking은 영속성 컨텍스트가 엔티티의 스냅샷을 저장하고 flush 시점에 비교하여 변경 사항을 자동으로 감지하는 메커니즘이다.

Transaction Commit, EntityManager Flush, JPQL 사용 시점에 flush가 발생하고 이때 Dirty Checking이 수행된다.

기본적으로 모든 필드를 업데이트하지만 @DynamicUpdate를 사용하면 변경된 필드만 업데이트할 수 있다. 많은 필드를 가진 엔티티나 컬럼 수준 잠금을 사용하는 경우 성능 향상을 기대할 수 있다.

준영속 상태나 비영속 상태의 엔티티는 Dirty Checking 대상에서 제외된다. 영속성 컨텍스트의 관리를 받아야 한다.

대량 업데이트 시에는 다음을 통해 성능을 최적화할 수 있다.

- JDBC 배치 설정
- 사용자 정의 수정 쿼리
- Projection 활용
