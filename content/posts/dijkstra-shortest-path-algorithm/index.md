---
title: "다익스트라(Dijkstra) 알고리즘 알아보기"
date: 2024-06-17T16:52:43+09:00
tags: ["다익스트라", "Dijkstra", "알고리즘", "최단 경로"]
description: "네덜란드의 컴퓨터 과학자 Edsger W. Dijkstra가 1956년에 발명한 다익스트라 알고리즘은 그래프에서 시작 정점으로부터 다른 모든 정점까지의 최단 경로를 찾는 대표적인 알고리즘이다. 탐욕 알고리즘(Greedy Algorithm) 방식을 사용하며 우선순위 큐를 활용한 Min Heap 구조로 구현하여 O(E log V)의 시간 복잡도를 달성한다. 음수 가중치를 처리할 수 없다는 제약이 있어 이 경우 Bellman-Ford 알고리즘을 사용해야 하지만, 네트워크 라우팅 프로토콜(OSPF), GPS 내비게이션 시스템, 소셜 네트워크의 최단 연결 경로 탐색, 게임 AI의 경로 탐색 등 실제 세계에서 광범위하게 응용되고 있다."
draft: false
---

## 다익스트라 알고리즘

최단 경로를 찾는 알고리즘 중 하나로, 다익스트라 알고리즘은 시작 정점에서 다른 모든 정점까지의 최단 경로를 찾는 알고리즘이며, 너비 우선 탐색(BFS)와 유사하게 각 정점까지의 최단 거리를 저장하면서 탐색한다.

## 다익스트라 알고리즘의 역사

네덜란드의 컴퓨터 과학자 Edsger W. Dijkstra가 1956년에 발명한 다익스트라 알고리즘은 그래프 이론에서 가장 유명하고 널리 사용되는 알고리즘 중 하나이다. Dijkstra는 이 알고리즘을 처음 고안할 당시 펜과 종이를 사용하지 않고 머릿속으로만 설계했다고 알려져 있으며, 이 알고리즘은 네트워크 라우팅, GPS 내비게이션, 소셜 네트워크 분석 등 실제 세계의 수많은 응용 분야에서 핵심적인 역할을 하고 있다. 현대 인터넷의 라우팅 프로토콜인 OSPF(Open Shortest Path First)도 다익스트라 알고리즘을 기반으로 하며, 우리가 매일 사용하는 지도 애플리케이션의 최단 경로 탐색 기능도 이 알고리즘의 변형을 활용하고 있다.

## 알고리즘 동작 원리

다익스트라 알고리즘은 탐욕 알고리즘(Greedy Algorithm) 접근 방식을 사용하여 매 단계마다 현재까지 발견된 정점 중에서 시작 정점으로부터의 거리가 가장 짧은 정점을 선택하고, 이 정점을 통해 다른 정점들로 가는 경로를 갱신한다. 이 과정의 핵심은 한 번 확정된 정점의 최단 거리는 절대 변하지 않는다는 것이며, 이는 모든 간선의 가중치가 0 이상이라는 전제 조건 하에서 수학적으로 증명되어 있다. 알고리즘은 시작 정점부터 점진적으로 확장해 나가면서 각 정점까지의 최단 경로를 확정해 나가며, 이러한 방식으로 모든 정점까지의 최단 경로를 효율적으로 찾아낸다.

### 순서

1. 시작 정점에서 각 정점까지의 거리를 저장하는 배열을 초기화한다.

2. 시작 정점을 방문 처리한다.

3. 큐에 시작 정점을 넣는다.

4. 큐가 빌 때까지 다음을 반복한다.

    1. 큐에서 정점을 꺼낸다.

    2. 해당 정점과 연결된 정점들을 탐색한다.

    3. 시작 정점에서 해당 정점까지의 거리가 시작 정점에서 현재 정점까지의 거리 + 현재 정점에서 해당 정점까지의 거리보다 크다면, 시작 정점에서 해당 정점까지의 거리를 갱신한다.

    4. 해당 정점을 방문 처리하고 큐에 넣는다.

    이때 시작 정점에서 해당 정점까지의 거리를 갱신할 때, 우선순위 큐를 사용하여 거리가 가장 짧은 정점을 먼저 탐색하도록 한다.

## 우선순위 큐의 역할

다익스트라 알고리즘에서 우선순위 큐는 매우 중요한 역할을 하며, 일반 큐를 사용하지 않고 우선순위 큐를 사용하는 이유는 알고리즘의 효율성과 직접적으로 연결되어 있다. 일반 큐를 사용하면 매번 거리가 가장 짧은 정점을 찾기 위해 모든 정점을 순회해야 하므로 O(V)의 시간이 소요되지만, 우선순위 큐를 사용하면 Min Heap 구조를 통해 O(log V)의 시간에 최소값을 추출할 수 있다.

### Min Heap 구조

우선순위 큐는 내부적으로 Min Heap(최소 힙) 자료구조로 구현되며, 이는 부모 노드가 항상 자식 노드보다 작은 값을 가지는 완전 이진 트리 형태이다. 이 구조를 통해 삽입(push) 연산과 최소값 추출(pop) 연산을 모두 O(log V)의 시간 복잡도로 수행할 수 있으며, 힙의 루트 노드에 항상 가장 작은 값이 위치하므로 최소값 확인도 O(1)에 가능하다.

### 우선순위 큐 사용 비교

우선순위 큐 없이 구현하는 경우, 매 단계마다 아직 방문하지 않은 모든 정점을 선형 탐색하여 최소 거리를 가진 정점을 찾아야 하므로 전체 시간 복잡도가 O(V^2)이 된다. 반면 우선순위 큐를 사용하면 각 정점을 큐에서 한 번씩 꺼내고(O(V log V)), 각 간선에 대해 한 번씩 거리 갱신을 수행하므로(O(E log V)) 전체 시간 복잡도가 O((V + E) log V)로 개선되며, 간선의 수가 정점의 수보다 충분히 많은 일반적인 그래프에서는 O(E log V)로 표현할 수 있다.

### 예제 코드

> 우선순위 큐를 사용하는 이유는 시작 정점에서 해당 정점까지의 거리를 갱신할 때, 거리가 가장 짧은 정점을 빠르게 구하기 위함이다.

```cpp
#include <iostream>
#include <limits.h>
#include <vector>
#include <queue>
using std::cin;
using std::cout;
using std::greater;
using std::pair;
using std::priority_queue;
using std::vector;

#define INF 1000000000

int main()
{
    int n, m;
    cin >> n >> m;

    vector<vector<pair<int, int>>> graph(n + 1);
    vector<int> dist(n + 1, INF);
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;

    for (int i = 0; i < m; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        graph[a].push_back({b, c});
    }

    int start, end;
    cin >> start >> end;

    dist[start] = 0;
    pq.push({0, start});

    while (!pq.empty())
    {
        int cost = pq.top().first;
        int cur = pq.top().second;
        pq.pop();

        if (dist[cur] < cost)
        {
            continue;
        }

        for(vector<pair<int,int>> next : graph[cur])
        {
            int nextNode = next.first;
            int nextCost = next.second;

            if (dist[nextNode] > cost + nextCost)
            {
                dist[nextNode] = cost + nextCost;
                pq.push({dist[nextNode], nextNode});
            }
        }
    }

    cout << dist[end] << '\n';

    return 0;
}
```

## 시간 복잡도 분석

다익스트라 알고리즘의 시간 복잡도는 구현 방식에 따라 달라지며, 그래프의 특성에 따라 최적의 구현 방식이 다를 수 있다.

### 우선순위 큐 사용 시: O((V + E) log V) 또는 O(E log V)

우선순위 큐를 사용한 구현에서는 각 정점을 큐에서 최대 한 번씩 꺼내므로 O(V log V)의 시간이 소요되고, 각 간선에 대해 최대 한 번씩 거리 갱신 및 큐 삽입 연산을 수행하므로 O(E log V)의 시간이 소요되며, 따라서 전체 시간 복잡도는 O((V + E) log V)이다. 연결된 그래프에서는 E ≥ V - 1이므로 일반적으로 O(E log V)로 표현하며, 여기서 V는 정점의 개수, E는 간선의 개수를 의미한다.

### 우선순위 큐 미사용 시: O(V^2)

우선순위 큐를 사용하지 않고 배열로 구현하는 경우, 매 단계마다 O(V)의 시간을 들여 최소 거리 정점을 찾아야 하므로 V개의 정점에 대해 총 O(V^2)의 시간 복잡도를 가진다. 이 방식은 간단하게 구현할 수 있지만 대부분의 경우 우선순위 큐를 사용하는 방식보다 느리며, 다만 매우 밀집된 그래프에서는 효율적일 수 있다.

### 밀집 그래프 vs 희소 그래프에서의 성능

밀집 그래프(Dense Graph)는 간선의 수가 E ≈ V^2인 그래프로, 이 경우 우선순위 큐 버전의 시간 복잡도는 O(V^2 log V)가 되어 배열 버전의 O(V^2)보다 느릴 수 있다. 반면 희소 그래프(Sparse Graph)는 간선의 수가 E ≈ V인 그래프로, 이 경우 우선순위 큐 버전이 O(V log V)로 배열 버전의 O(V^2)보다 훨씬 빠르며, 실제 응용에서는 희소 그래프가 더 흔하므로 일반적으로 우선순위 큐를 사용한 구현이 선호된다.

## 음수 가중치 문제

다익스트라 알고리즘은 모든 간선의 가중치가 0 이상이어야 한다는 중요한 제약 조건을 가지며, 음수 가중치가 있는 그래프에서는 올바른 결과를 보장할 수 없다.

### 음수 가중치에서 작동하지 않는 이유

다익스트라 알고리즘의 핵심 원리는 한 번 확정된 정점의 최단 거리는 변하지 않는다는 것인데, 음수 가중치가 존재하면 이미 확정된 정점을 거쳐 가는 경로가 나중에 더 짧은 경로로 발견될 수 있어 이 가정이 깨진다. 예를 들어 정점 A에서 B로 가는 거리를 5로 확정했더라도, 나중에 발견한 C를 거쳐 가는 경로가 A→C(거리 10) + C→B(거리 -8) = 2로 더 짧을 수 있으며, 알고리즘은 이미 B를 확정했기 때문에 이 경로를 고려하지 않아 잘못된 결과를 산출한다.

### 반례 설명

다음과 같은 간단한 그래프를 생각해 보자. 정점 1에서 시작하여 정점 3까지의 최단 경로를 찾는다고 가정하면, 간선은 1→2(가중치 5), 1→3(가중치 2), 2→3(가중치 -4)로 구성되어 있다. 다익스트라 알고리즘은 먼저 정점 3을 거리 2로 확정하고, 그 다음 정점 2를 거리 5로 확정하지만, 실제 최단 경로는 1→2→3으로 거리 1이며, 알고리즘이 정점 3을 너무 일찍 확정했기 때문에 이 경로를 놓치게 된다.

### 음수 가중치 처리 방법

음수 가중치가 있는 그래프에서 최단 경로를 찾아야 한다면 Bellman-Ford 알고리즘을 사용해야 하며, 이 알고리즘은 시간 복잡도가 O(VE)로 다익스트라보다 느리지만 음수 가중치를 올바르게 처리할 수 있고 음수 사이클의 존재 여부도 감지할 수 있다. 음수 사이클이 없다는 것이 보장되는 경우에만 Bellman-Ford를 사용하면 되며, 음수 사이클이 있으면 최단 경로가 정의되지 않는다.

## 실제 응용 사례

다익스트라 알고리즘은 이론적 가치뿐만 아니라 실제 세계에서 광범위하게 활용되고 있으며, 우리가 일상적으로 사용하는 많은 서비스의 핵심 기술이다.

### 네트워크 라우팅 프로토콜 (OSPF)

인터넷의 라우팅 프로토콜 중 하나인 OSPF(Open Shortest Path First)는 다익스트라 알고리즘을 사용하여 네트워크 상에서 데이터 패킷이 전송될 최적의 경로를 계산하며, 각 라우터는 네트워크 토폴로지 정보를 바탕으로 자신으로부터 다른 모든 라우터까지의 최단 경로를 계산하고, 링크 비용(대역폭, 지연 시간 등)을 가중치로 사용하여 가장 효율적인 경로를 선택한다.

### GPS 내비게이션 시스템

자동차 내비게이션 시스템은 다익스트라 알고리즘 또는 그 변형(예: A* 알고리즘)을 사용하여 출발지에서 목적지까지의 최단 경로를 계산하며, 도로 네트워크를 그래프로 모델링하고 교차로는 정점으로, 도로는 간선으로 표현한다. 간선의 가중치는 거리, 예상 소요 시간, 통행료 등 다양한 요소를 고려하여 설정되며, 실시간 교통 정보를 반영하여 동적으로 경로를 재계산할 수도 있다.

### 소셜 네트워크 최단 연결 경로

소셜 네트워크 서비스에서 "6단계 분리 이론"을 확인하거나 두 사용자 간의 연결 경로를 찾는 기능은 다익스트라 알고리즘을 활용하며, 사용자를 정점으로, 친구 관계를 간선으로 모델링하고, 모든 간선의 가중치를 동일하게 설정하면 최단 경로가 곧 최소 단계의 연결을 의미한다. LinkedIn의 "당신은 어떻게 연결되어 있습니까" 기능이나 Facebook의 친구 추천 시스템이 이러한 원리를 사용한다.

### 게임 AI의 경로 탐색

게임에서 NPC(Non-Player Character)나 적 캐릭터가 플레이어를 추적하거나 목표 지점으로 이동할 때 다익스트라 알고리즘의 변형인 A* 알고리즘을 주로 사용하며, 맵을 그리드나 그래프로 표현하고 각 칸이나 노드를 정점으로, 이동 가능한 경로를 간선으로 모델링한다. A* 알고리즘은 다익스트라에 휴리스틱 함수를 추가하여 목표 지점 방향으로 우선적으로 탐색함으로써 성능을 더욱 개선하며, 실시간 전략 게임(RTS)이나 롤플레잉 게임(RPG)에서 필수적인 기술이다.

## 다른 알고리즘과의 비교

최단 경로 문제를 해결하는 알고리즘은 다익스트라 외에도 여러 가지가 있으며, 각각의 특성과 적용 상황이 다르다.

### Bellman-Ford 알고리즘

Bellman-Ford 알고리즘은 음수 가중치를 허용하며 O(VE)의 시간 복잡도를 가지고, 음수 사이클의 존재 여부를 감지할 수 있다는 장점이 있다. 다익스트라 알고리즘보다 느리지만 더 범용적으로 사용할 수 있으며, 모든 간선에 대해 V-1번의 완화(relaxation) 연산을 수행하여 최단 경로를 찾고, 환율 차익 거래나 네트워크 흐름 문제 등 음수 가중치가 자연스럽게 발생하는 문제에 적합하다.

### Floyd-Warshall 알고리즘

Floyd-Warshall 알고리즘은 모든 정점 쌍 간의 최단 경로를 한 번에 계산하며 O(V^3)의 시간 복잡도를 가지고, 동적 계획법(Dynamic Programming)을 사용하여 구현이 간단하다는 특징이 있다. 단일 출발점이 아닌 모든 쌍의 최단 경로가 필요한 경우에 사용되며, 그래프가 작거나 모든 경로 정보가 필요한 경우에 효율적이고, 음수 가중치도 처리할 수 있지만 음수 사이클이 있으면 안 된다.

### A* 알고리즘

A* 알고리즘은 다익스트라 알고리즘에 휴리스틱 함수를 추가한 변형으로, 목표 지점까지의 예상 거리를 고려하여 탐색을 목표 지향적으로 수행한다. 적절한 휴리스틱을 사용하면 다익스트라보다 훨씬 빠르게 최단 경로를 찾을 수 있으며, 휴리스틱이 실제 거리를 과대 평가하지 않으면(admissible) 최적해를 보장하고, 게임 개발, 로봇 공학, 내비게이션 시스템 등에서 가장 널리 사용되는 경로 탐색 알고리즘이다.

### 장점

-   다익스트라 알고리즘은 시작 정점에서 다른 모든 정점까지의 최단 경로를 찾을 수 있다.
-   우선순위 큐를 사용하면 효율적인 시간 복잡도 O(E log V)를 달성한다.
-   음수 가중치가 없는 그래프에서는 항상 최적해를 보장한다.

### 단점

-   다익스트라 알고리즘은 음의 가중치가 있는 그래프에서 사용할 수 없다.
-   단일 출발점에서만 작동하므로, 모든 쌍의 최단 경로가 필요한 경우 V번 실행해야 한다.
-   우선순위 큐 구현에 추가 메모리가 필요하다.
