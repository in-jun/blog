---
title: "CI/CD 지속적 통합과 배포"
date: 2024-06-10T17:14:26+09:00
tags: ["CI/CD", "DevOps", "자동화"]
description: "지속적 통합과 지속적 배포의 개념과 구현 방법을 다룬다."
draft: false
---

CI/CD는 Continuous Integration(지속적 통합)과 Continuous Delivery/Deployment(지속적 제공/배포)의 약자로, 소프트웨어 개발 과정에서 코드 변경 사항을 자동으로 빌드, 테스트, 배포하는 일련의 자동화된 프로세스를 의미하며, 현대 소프트웨어 개발에서 DevOps 문화의 핵심 요소로 자리 잡았다. CI/CD는 개발자들이 코드를 더 자주, 더 안전하게 통합하고 배포할 수 있게 해주며, 이를 통해 소프트웨어 릴리스 주기를 단축하고 버그를 조기에 발견하여 제품 품질을 향상시킬 수 있다.

## CI/CD의 역사와 유래

CI/CD는 1990년대 소프트웨어 개발 방법론의 혁신 속에서 탄생했으며, Extreme Programming(XP)의 핵심 실천 방법 중 하나로 시작되어 현재까지 지속적으로 발전해왔다.

### Continuous Integration의 탄생

Continuous Integration이라는 용어는 1994년 UML(Unified Modeling Language)의 개발자 중 한 명인 Grady Booch가 자신의 저서에서 처음 사용했으며, 당시에는 코드를 자주 통합하여 충돌을 최소화한다는 개념으로 제시되었다. 그러나 오늘날 우리가 실천하는 CI의 구체적인 형태는 1990년대 중반 Kent Beck이 Extreme Programming의 12가지 핵심 실천 방법 중 하나로 정립하면서 본격적으로 발전하기 시작했으며, Kent Beck은 1996년 Chrysler의 C3(Chrysler Comprehensive Compensation) 프로젝트에서 XP 방법론을 적용하면서 CI의 효과를 실증적으로 입증했고, 이 프로젝트는 모든 개발자가 지속적 통합의 가치를 경험하고 받아들이는 계기가 되었다.

### CI/CD의 대중화

2000년 Agile Alliance의 창립 멤버 중 한 명인 Martin Fowler가 ThoughtWorks에서 CI의 내부 옹호자가 되면서 CI/CD가 본격적으로 대중화되기 시작했으며, 그는 2000년에 "Continuous Integration"이라는 유명한 아티클을 발표하여 CI의 핵심 원칙과 모범 사례를 체계적으로 정리했고, 현재까지도 ThoughtWorks의 Chief Scientist로 활동하면서 CI/CD와 소프트웨어 개발 방법론의 발전에 지속적으로 기여하고 있다.

### Continuous Delivery의 발전

2010년 Jez Humble과 David Farley가 "Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment Automation"이라는 책을 출간하면서 Continuous Delivery 개념이 체계적으로 정립되었으며, 이 책에서 Martin Fowler가 제시한 Continuous Integration 아이디어를 확장하여 배포 파이프라인(Deployment Pipeline)이라는 개념을 도입했고, 코드 커밋부터 프로덕션 배포까지의 전체 과정을 자동화하는 방법론을 제시했다. 이후 클라우드 컴퓨팅의 발전, 컨테이너 기술의 등장, Kubernetes의 대중화 등과 맞물려 CI/CD는 더욱 발전했으며, Netflix, Amazon, Google 등 대형 기술 기업들이 CI/CD를 적극적으로 도입하면서 하루에도 수백, 수천 번의 배포가 가능한 시대가 열리게 되었다.

## CI(Continuous Integration)란 무엇인가

> **CI(Continuous Integration)란?**
>
> 여러 개발자가 작성한 코드를 지속적으로 메인 브랜치에 통합하고, 통합할 때마다 자동으로 빌드와 테스트를 수행하여 통합 오류를 조기에 발견하고 해결하는 소프트웨어 개발 실천 방법이다.

CI의 핵심 아이디어는 "작은 변경을 자주 통합하라"는 것으로, 전통적인 소프트웨어 개발에서는 개발자들이 각자 오랜 기간 독립적으로 작업한 후 마지막에 코드를 통합하는 "Big Bang Integration" 방식을 사용했는데, 이 방식은 통합 시점에 수많은 충돌과 버그가 발생하여 "통합 지옥(Integration Hell)"이라 불리는 상황을 초래했다. CI는 이러한 문제를 해결하기 위해 코드를 작은 단위로 자주 통합하고, 매번 자동화된 검증 과정을 거치도록 함으로써 문제를 조기에 발견하고 해결할 수 있게 해준다.

### CI의 핵심 원칙

**단일 소스 저장소 유지**: 모든 소스 코드, 테스트 코드, 빌드 스크립트, 설정 파일 등이 하나의 버전 관리 시스템(Git, SVN 등)에서 관리되어야 하며, 팀의 모든 구성원이 동일한 저장소에서 작업해야 한다.

**자주 커밋하기**: 개발자는 적어도 하루에 한 번 이상 메인 브랜치에 코드를 통합해야 하며, 이상적으로는 몇 시간마다 작은 변경 사항을 커밋하는 것이 좋고, 이렇게 하면 충돌을 최소화하고 문제 발생 시 원인을 빠르게 파악할 수 있다.

**빌드 자동화**: 코드가 커밋될 때마다 자동으로 빌드가 실행되어야 하며, 빌드 과정에는 컴파일, 의존성 해결, 정적 분석 등이 포함되고, 빌드는 단일 명령어로 실행될 수 있어야 한다.

**테스트 자동화**: 빌드 후에는 자동화된 테스트가 실행되어 코드의 기능적 정확성을 검증해야 하며, 유닛 테스트, 통합 테스트, 기능 테스트 등 다양한 수준의 테스트가 포함될 수 있다.

**빠른 빌드 유지**: 빌드와 테스트는 가능한 한 빠르게 완료되어야 하며, 일반적으로 10분 이내가 이상적이고, 빌드가 너무 오래 걸리면 개발자들이 빌드 결과를 기다리지 않고 다른 작업을 시작하게 되어 CI의 효과가 감소한다.

**즉각적인 피드백**: 빌드나 테스트가 실패하면 개발팀에 즉시 알림이 전달되어야 하며, 실패한 빌드를 수정하는 것이 새로운 기능 개발보다 우선시되어야 한다.

### CI 파이프라인의 동작 과정

**1단계: 코드 커밋**

개발자가 로컬에서 작업을 완료하고 변경 사항을 버전 관리 시스템(Git 등)에 푸시하면 CI 파이프라인이 트리거되며, 일반적으로 Pull Request를 생성하거나 특정 브랜치에 푸시할 때 자동으로 시작된다.

**2단계: 소스 코드 체크아웃**

CI 서버가 최신 코드를 저장소에서 가져오며, 이 과정에서 브랜치 전략에 따라 특정 브랜치의 코드를 체크아웃하거나 Pull Request의 변경 사항을 메인 브랜치와 병합한 상태로 체크아웃할 수 있다.

**3단계: 의존성 설치**

프로젝트에 필요한 라이브러리와 의존성을 설치하며, npm, pip, Maven, Gradle 등의 패키지 관리자를 통해 의존성을 해결하고, 캐싱을 활용하여 이 단계의 시간을 단축할 수 있다.

**4단계: 빌드**

소스 코드를 컴파일하고 실행 가능한 형태로 빌드하며, 이 과정에서 문법 오류, 타입 오류, 의존성 충돌 등의 문제가 발견될 수 있고, 빌드가 실패하면 파이프라인이 중단되고 개발자에게 알림이 전송된다.

**5단계: 테스트 실행**

빌드가 성공하면 다양한 수준의 자동화된 테스트가 실행되며, 유닛 테스트는 개별 함수나 클래스의 동작을 검증하고, 통합 테스트는 여러 컴포넌트 간의 상호작용을 검증하며, E2E(End-to-End) 테스트는 사용자 관점에서 전체 시스템의 동작을 검증한다.

**6단계: 코드 품질 검사**

SonarQube, ESLint, Checkstyle 등의 도구를 사용하여 코드 품질을 분석하며, 코딩 컨벤션 준수 여부, 코드 복잡도, 중복 코드, 잠재적 버그 패턴 등을 검사하고, 보안 취약점 스캔도 이 단계에서 수행될 수 있다.

**7단계: 아티팩트 생성**

모든 검증이 통과하면 배포 가능한 아티팩트(JAR, WAR, Docker 이미지 등)를 생성하며, 이 아티팩트는 버전 태그가 지정되어 아티팩트 저장소(Nexus, Artifactory, Docker Registry 등)에 저장된다.

## CD의 두 가지 의미

CD는 Continuous Delivery(지속적 제공)와 Continuous Deployment(지속적 배포) 두 가지 의미로 사용되며, 두 개념은 밀접하게 관련되어 있지만 프로덕션 배포에 대한 접근 방식에서 중요한 차이가 있다.

### Continuous Delivery (지속적 제공)

> **Continuous Delivery란?**
>
> 모든 코드 변경이 자동화된 빌드, 테스트, 검증 과정을 거쳐 언제든지 프로덕션에 배포할 준비가 된 상태를 유지하는 소프트웨어 개발 접근 방식으로, 실제 프로덕션 배포는 비즈니스 결정에 따라 수동으로 승인하여 수행한다.

Continuous Delivery의 핵심은 "항상 릴리스 가능한 상태를 유지하라"는 것으로, 코드가 메인 브랜치에 병합되면 자동화된 파이프라인을 통해 스테이징 환경까지 배포되고, 모든 테스트와 검증이 완료된 상태에서 버튼 하나로 프로덕션에 배포할 수 있는 상태가 된다. 그러나 실제 프로덕션 배포는 제품 관리자, 비즈니스 담당자 등의 승인을 거쳐 수동으로 트리거된다.

**Continuous Delivery가 적합한 환경**:
- 규제가 엄격한 산업(금융, 의료, 공공 기관 등)에서 배포 전 승인 프로세스가 필요한 경우
- 마케팅 캠페인, 비즈니스 이벤트 등과 릴리스 시점을 조율해야 하는 경우
- 사용자에게 미치는 영향이 크고 신중한 릴리스 결정이 필요한 경우
- 롤백이 복잡하거나 비용이 많이 드는 시스템

### Continuous Deployment (지속적 배포)

> **Continuous Deployment란?**
>
> Continuous Delivery에서 한 단계 더 나아가, 모든 자동화된 테스트와 검증을 통과한 코드 변경이 사람의 개입 없이 자동으로 프로덕션 환경에 배포되는 소프트웨어 개발 접근 방식이다.

Continuous Deployment는 완전한 자동화를 추구하며, 개발자가 코드를 커밋하면 CI 파이프라인의 모든 단계(빌드, 테스트, 품질 검사, 스테이징 배포, 스테이징 테스트 등)를 자동으로 거쳐 문제가 없으면 프로덕션에도 자동으로 배포된다. 이를 위해서는 높은 수준의 테스트 커버리지, 견고한 모니터링 시스템, 빠른 롤백 메커니즘 등이 필수적으로 갖춰져 있어야 한다.

**Continuous Deployment가 적합한 환경**:
- 빠른 사용자 피드백과 반복이 중요한 스타트업이나 웹 서비스
- SaaS(Software as a Service) 플랫폼
- A/B 테스팅, 실험적 기능 출시 등을 자주 수행하는 환경
- 마이크로서비스 아키텍처를 채택하여 독립적인 배포가 가능한 환경
- Netflix, Amazon, Etsy 등 하루에도 여러 번 배포하는 대형 기술 기업

### Continuous Delivery vs Continuous Deployment 비교

| 구분 | Continuous Delivery | Continuous Deployment |
|------|---------------------|----------------------|
| 프로덕션 배포 | 수동 승인 후 배포 | 자동 배포 |
| 배포 빈도 | 비즈니스 결정에 따름 | 코드 변경마다 즉시 |
| 필요 조건 | 자동화된 테스트, 스테이징 환경 | 높은 테스트 커버리지, 모니터링, 롤백 메커니즘 |
| 적합한 환경 | 규제 산업, 신중한 릴리스 필요 | 빠른 반복, 웹 서비스, SaaS |
| 위험 관리 | 사람이 최종 판단 | 자동화된 검증에 의존 |

## 주요 CI/CD 도구 비교

CI/CD를 구현하기 위한 다양한 도구들이 있으며, 각 도구는 고유한 특징과 장단점을 가지고 있어 프로젝트의 요구사항과 환경에 맞는 도구를 선택하는 것이 중요하다.

### Jenkins

Jenkins는 2011년 Hudson 프로젝트에서 분리되어 탄생한 Java 기반의 오픈소스 CI/CD 도구로, "CI의 아버지"라 불릴 정도로 가장 오래되고 널리 사용되는 도구이며, 1,800개 이상의 플러그인을 통해 거의 모든 개발 도구와 통합할 수 있다.

**장점**:
- 방대한 플러그인 생태계로 GitHub, GitLab, Bitbucket 등 모든 SCM과 Docker, Kubernetes, AWS, Azure 등 대부분의 기술 스택을 지원
- Jenkinsfile을 통한 Pipeline as Code로 파이프라인을 코드로 관리할 수 있음
- 완전한 커스터마이징이 가능하여 복잡한 워크플로우도 구현 가능
- 대규모 엔터프라이즈 환경에서 검증된 안정성
- 활발한 커뮤니티와 풍부한 문서

**단점**:
- 자체 서버를 구축하고 운영해야 하므로 인프라 관리 부담이 있음
- 초기 설정과 유지보수에 상당한 노력이 필요
- 플러그인 간의 호환성 문제가 발생할 수 있음
- 현대적인 도구들에 비해 UI/UX가 오래된 느낌

### GitHub Actions

GitHub Actions는 2019년 GitHub에서 출시한 CI/CD 플랫폼으로, GitHub 저장소와 네이티브로 통합되어 별도의 설정 없이 바로 사용할 수 있으며, YAML 파일로 워크플로우를 정의하고 GitHub Marketplace에서 커뮤니티가 만든 액션을 재사용할 수 있다.

**장점**:
- GitHub 저장소와 완벽하게 통합되어 Pull Request, Issue 등과 연동이 자연스러움
- GitHub Marketplace에서 15,000개 이상의 사전 구축된 액션을 사용 가능
- 매트릭스 빌드로 여러 OS, 언어 버전 조합을 쉽게 테스트 가능
- 퍼블릭 저장소는 무료로 무제한 사용 가능
- YAML 기반의 직관적인 워크플로우 정의

**단점**:
- 프라이빗 저장소의 경우 사용량에 따른 비용 발생
- GitHub 플랫폼에 종속되어 다른 Git 호스팅 서비스와 통합이 어려움
- 셀프 호스팅 러너 설정이 Jenkins만큼 유연하지 않음
- 복잡한 워크플로우의 경우 YAML 파일이 장황해질 수 있음

### GitLab CI/CD

GitLab CI/CD는 GitLab에 내장된 CI/CD 솔루션으로, 소스 코드 관리, 이슈 트래킹, CI/CD, 보안 스캐닝, 패키지 레지스트리 등을 하나의 플랫폼에서 제공하는 통합 DevOps 플랫폼의 일부이다.

**장점**:
- 버전 관리부터 배포까지 전체 DevOps 라이프사이클을 단일 플랫폼에서 관리
- SAST, DAST, 컨테이너 스캐닝 등 보안 기능이 기본 내장
- Auto DevOps 기능으로 최소한의 설정으로 파이프라인 자동 구성 가능
- Kubernetes와의 긴밀한 통합
- 클라우드 호스팅과 셀프 호스팅 모두 지원

**단점**:
- 전체 기능을 사용하려면 유료 플랜이 필요
- GitLab 플랫폼에 종속
- 비표준 워크플로우의 경우 유연성이 Jenkins보다 제한적

### CircleCI

CircleCI는 클라우드 기반 CI/CD 서비스로, 빠른 빌드 속도와 우수한 Docker 지원으로 알려져 있으며, Meta, Adobe, Spotify 등 대형 기술 기업들이 사용하고 있다.

**장점**:
- 업계 최고 수준의 빌드 속도와 성능
- Docker를 네이티브로 지원하여 컨테이너 기반 워크플로우에 최적화
- 강력한 캐싱 메커니즘으로 빌드 시간 단축
- Orbs(재사용 가능한 설정 패키지)를 통한 설정 간소화
- SSH 디버깅으로 빌드 실패 시 문제 해결 용이

**단점**:
- 무료 티어의 제한이 있음
- 복잡한 워크플로우 설정 시 학습 곡선이 있음
- 가끔 서비스 장애 발생

### 도구 선택 가이드

| 상황 | 추천 도구 |
|------|----------|
| GitHub 사용, 소규모 팀 | GitHub Actions |
| 전체 DevOps 플랫폼 통합 필요 | GitLab CI/CD |
| 대규모 엔터프라이즈, 복잡한 요구사항 | Jenkins |
| 빠른 빌드 속도, Docker 중심 | CircleCI |
| 셀프 호스팅 필수 | Jenkins 또는 GitLab (Self-Managed) |
| 비용 최소화 (오픈소스 프로젝트) | GitHub Actions |

## CI/CD 파이프라인 구축 모범 사례

CI/CD 파이프라인은 한 번 구축하고 끝나는 것이 아니라 지속적인 관리와 개선이 필요하며, 다음의 모범 사례들을 참고하여 효과적인 파이프라인을 구축하고 발전시켜 나가야 한다.

### 점진적 접근

CI/CD 도입은 한 번에 완벽한 파이프라인을 구축하려 하기보다 점진적으로 접근하는 것이 효과적이며, 가장 중요한 프로젝트나 팀부터 시작하여 성공 사례를 만들고 이를 조직 전체로 확산시키는 전략이 권장된다.

1. **1단계**: 기본적인 빌드 자동화부터 시작
2. **2단계**: 유닛 테스트 자동화 추가
3. **3단계**: 통합 테스트, 코드 품질 검사 추가
4. **4단계**: 스테이징 환경 자동 배포
5. **5단계**: 프로덕션 배포 자동화 (Continuous Delivery/Deployment)

### 문화적 변화

CI/CD는 단순한 도구의 도입이 아니라 팀 전체의 업무 방식과 문화를 변화시키는 것이며, 성공적인 CI/CD 도입을 위해서는 다음과 같은 문화적 변화가 필요하다.

- **공유된 책임**: 빌드와 테스트의 성공은 개인이 아닌 팀 전체의 책임
- **빠른 피드백 수용**: 빌드 실패를 비난이 아닌 개선의 기회로 인식
- **자동화 우선 사고**: 수동 작업을 최소화하고 가능한 모든 것을 자동화
- **지속적 학습**: 파이프라인 실패에서 배우고 프로세스를 지속적으로 개선
- **투명성**: 빌드 상태, 배포 현황 등을 팀 전체가 볼 수 있도록 공유

### 성능 최적화

CI/CD 파이프라인의 실행 시간이 길어지면 개발자의 생산성이 저하되고 CI/CD의 이점이 감소하므로, 파이프라인 성능을 지속적으로 최적화해야 한다.

**병렬화**: 독립적인 테스트와 작업은 동시에 실행하여 전체 파이프라인 시간을 단축하며, 테스트 스위트를 적절히 분할하여 여러 노드에서 병렬로 실행할 수 있다.

**캐싱 전략**: 의존성 라이브러리, 빌드 결과물, Docker 레이어 등을 캐싱하여 반복적인 다운로드와 빌드 시간을 절약하며, 대부분의 CI/CD 도구가 캐싱 기능을 제공한다.

**선택적 실행**: 변경된 코드와 관련된 테스트만 실행하는 전략을 적용하거나, 변경 범위에 따라 파이프라인의 일부만 실행하여 불필요한 작업을 줄일 수 있다.

**리소스 최적화**: 빌드에 필요한 리소스(CPU, 메모리)를 적절히 할당하고, 무거운 테스트는 덜 자주 실행되는 별도의 파이프라인으로 분리하는 것을 고려한다.

### 모니터링과 지속적 개선

파이프라인의 성능과 안정성을 지속적으로 모니터링하고 개선해야 하며, 다음과 같은 지표를 추적하는 것이 권장된다.

- **빌드 시간**: 평균 빌드 시간과 추세를 모니터링하여 성능 저하를 조기에 감지
- **빌드 성공률**: 실패율이 높다면 테스트의 안정성이나 코드 품질 문제를 점검
- **배포 빈도**: 얼마나 자주 프로덕션에 배포하는지 추적
- **변경 리드 타임**: 코드 커밋부터 프로덕션 배포까지의 시간
- **평균 복구 시간(MTTR)**: 장애 발생 시 복구까지 걸리는 시간

### 보안 고려사항

CI/CD 파이프라인은 소스 코드, 자격 증명, 배포 권한 등 민감한 정보에 접근하므로 보안에 특별한 주의가 필요하다.

- **시크릿 관리**: API 키, 비밀번호 등을 코드에 하드코딩하지 않고 CI/CD 도구의 시크릿 관리 기능이나 HashiCorp Vault 같은 전용 도구를 사용
- **최소 권한 원칙**: 파이프라인에 필요한 최소한의 권한만 부여
- **보안 스캐닝**: SAST, DAST, 의존성 취약점 스캔 등을 파이프라인에 통합
- **감사 로그**: 파이프라인 실행, 배포 이력 등을 기록하고 보관

## 결론

CI/CD는 1990년대 Extreme Programming에서 시작되어 Kent Beck과 Martin Fowler, Jez Humble 등에 의해 발전된 소프트웨어 개발 방법론으로, 빌드 자동화와 테스트 자동화를 통해 코드 품질을 유지하고 배포 과정을 자동화하여 소프트웨어 릴리스 주기를 단축한다. Continuous Delivery는 수동 승인을 통해 안정적인 릴리스를 보장하고, Continuous Deployment는 완전 자동화로 빠른 피드백 루프를 실현하며, 조직의 상황과 요구사항에 맞는 접근 방식을 선택해야 한다. Jenkins, GitHub Actions, GitLab CI/CD, CircleCI 등 다양한 도구가 있으며 각각의 장단점이 있으므로 프로젝트의 규모, 사용 중인 플랫폼, 요구사항 등을 고려하여 선택해야 한다. 성공적인 CI/CD 구축을 위해서는 점진적 접근, 문화적 변화, 지속적인 개선이 필수적이며, 단순히 도구를 도입하는 것을 넘어 팀 전체가 자동화와 지속적 개선의 가치를 공유하는 문화를 만들어가야 한다.
