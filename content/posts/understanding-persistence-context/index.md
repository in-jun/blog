---
title: "영속성 컨텍스트 알아보기"
date: 2024-06-08T03:12:19+09:00
tags: ["ORM", "java"]
description: "영속성 컨텍스트의 필요성과 역할, 1차 캐시의 동작 원리와 장점, 동일성 보장 메커니즘, 쓰기 지연과 성능 최적화, 트랜잭션 범위 영속성 컨텍스트와 확장된 영속성 컨텍스트, OSIV 패턴과 문제점까지 정리"
draft: false
---

## 영속성 컨텍스트란

영속성 컨텍스트(Persistence Context)는 엔티티를 영구 저장하는 환경이라는 뜻이다. 애플리케이션이 데이터베이스에서 꺼내온 객체를 보관하는 역할을 하며 애플리케이션과 데이터베이스의 사이에 존재하는 가상의 데이터베이스이다.

### 영속성 컨텍스트의 역할

영속성 컨텍스트는 엔티티 매니저를 통해 엔티티를 조회하거나 저장할 때 엔티티를 보관하고 관리한다. 엔티티와 데이터베이스 간의 상태 변화를 추적한다.

### 제공 기능

영속성 컨텍스트는 엔티티 매니저에 의해 관리되며 다음과 같은 기능을 제공한다.

- **1차 캐시**: 엔티티를 임시 저장하여 반복 조회 시 성능 향상
- **변경 감지**: 엔티티의 변경사항을 자동으로 추적하여 UPDATE 쿼리 자동 생성
- **쓰기 지연**: 여러 쿼리를 모아 한 번에 실행하여 성능 최적화
- **동일성 보장**: 같은 트랜잭션 내에서 같은 엔티티에 대한 동일성 보장
- **지연 로딩**: 연관된 엔티티를 실제 사용 시점에 로딩

## 1차 캐시의 동작 원리와 장점

영속성 컨텍스트 내부에는 엔티티를 보관하는 저장소가 있는데 이것을 1차 캐시(First Level Cache)라고 부른다.

### 1차 캐시의 구조

1차 캐시는 Key-Value 형태의 구조를 가진다.

- **Key**: 엔티티의 식별자(ID)
- **Value**: 엔티티 인스턴스

### 조회 메커니즘

EntityManager를 통해 find 명령으로 데이터베이스를 조회할 때 다음 순서로 동작한다.

1. 영속성 컨텍스트의 1차 캐시를 먼저 조회
2. find 시에 입력받은 id 값이 1차 캐시에 존재하면 그 값을 찾아 리턴
3. 엔티티가 캐시에 없으면 데이터베이스에서 가져온 데이터를 1차 캐시에 저장

### 생명주기

1차 캐시는 트랜잭션이 시작하고 종료할 때까지만 유효하다.

- 트랜잭션 단위의 캐시
- 활성화하거나 비활성화할 수 있는 옵션이 아님
- 영속성 컨텍스트 자체가 사실상 1차 캐시

### 1차 캐시의 장점

데이터베이스 접근 횟수를 감소시킨다.

- 이후 같은 엔티티를 조회하면 1차 캐시에 같은 엔티티가 있으므로 데이터베이스를 조회하지 않음
- 1차 캐시의 엔티티를 그대로 반환
- 같은 엔티티는 같은 영속성 컨텍스트이므로 객체 동일성을 보장

### 성능 측면의 한계

10명의 요청이 들어오면 10개의 1차 캐시가 생성된다. 요청마다 생성되는 영속성 컨텍스트는 요청이 끝나고 트랜잭션이 종료될 때 함께 사라진다.

따라서 1차 캐시는 큰 성능 향상을 기대하기 어렵다. 1차 캐시는 성능보다 메커니즘에서 얻는 이점이 크다.

## 동일성 보장 메커니즘

JPA의 영속성 컨텍스트는 1차 캐시 메커니즘을 통해 엔티티 동일성을 보장한다.

### 동일성 보장 원리

em.find(Member.class, "member1")을 반복적으로 호출하면 영속성 컨텍스트는 1차 캐시에서 같은 엔티티 인스턴스를 반환한다.

1차 캐시가 같은 엔티티 인스턴스를 반환하기 때문에 JPA는 엔티티 동일성을 보장한다.

### 동일성 비교 예제

```java
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");
```

동일성 비교인 `a == b`가 true를 반환한다.

### 트랜잭션 격리 수준

이러한 동일성 보장 덕분에 애플리케이션 수준에서 REPEATABLE READ 수준의 트랜잭션 격리 수준을 제공한다.

- 데이터베이스 수준이 아닌 애플리케이션 수준에서 제공
- 영속성 컨텍스트가 다르면 엔티티는 다른 객체로 간주되므로 동일성이 보장되지 않음

## 쓰기 지연과 성능 최적화

영속성 컨텍스트는 트랜잭션을 지원하는 쓰기 지연(Transactional Write-Behind) 기능을 제공한다.

### 쓰기 지연의 동작 원리

엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않는다.

1. 내부 쿼리 저장소에 INSERT SQL을 모아둠
2. 트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보내서 저장

이를 트랜잭션을 지원하는 쓰기 지연이라 한다.

### SQL 배치 기능

쓰기 지연 덕분에 SQL 배치 기능을 사용할 수 있다.

예를 들어 5번의 INSERT SQL을 모아서 한 번에 데이터베이스로 보낼 수 있다. commit 직전까지 INSERT 쿼리를 해당 사이즈만큼 모아서 한 번에 처리한다.

### 성능 최적화 설정

성능 최적화를 위해서는 hibernate.default_batch_fetch_size를 설정해야 한다.

- 애플리케이션 특성에 따라 보통 100~1000의 값으로 설정
- 영속성 컨텍스트를 flush하지 않는 읽기 전용 최적화는 스냅샷 비교와 같은 무거운 로직들을 수행하지 않으므로 성능이 최적화됨

## 트랜잭션 범위 영속성 컨텍스트

스프링은 트랜잭션 범위의 영속성 컨텍스트 전략이 기본이다.

### 동작 방식

- 같은 트랜잭션 안에서는 같은 영속성 컨텍스트를 사용
- OSIV OFF 상태이므로 트랜잭션과 영속성 컨텍스트의 라이프사이클이 같음
- 트랜잭션이 시작하는 Service Layer에 진입해야 EntityManager가 생성됨

### 프레젠테이션 계층의 제약

컨트롤러나 뷰 같은 프레젠테이션 계층에서는 준영속 상태가 된다.

- 지연 로딩을 시도하면 예외가 발생
- 영속성 컨텍스트가 트랜잭션 범위로 제한됨

## OSIV 패턴과 문제점

OSIV(Open Session In View)는 영속성 컨텍스트를 뷰까지 열어두는 기능이다.

### OSIV의 동작 방식

1. 클라이언트 요청이 들어오면 서블릿 필터나 스프링 인터셉터에서 영속성 컨텍스트를 생성
2. 트랜잭션은 시작하지 않음
3. 서비스 계층에서 트랜잭션을 시작할 때 생성한 영속성 컨텍스트를 찾아와서 트랜잭션을 시작
4. 서비스 계층이 끝나면 영속성 컨텍스트를 flush하고 트랜잭션을 커밋
5. 트랜잭션을 끝내지만 영속성 컨텍스트는 종료하지 않음
6. 프레젠테이션까지 영속성 컨텍스트가 유지되므로 지연 로딩이 가능

### OSIV의 장점

View까지 영속성 컨텍스트가 살아있다면 View에서도 지연 로딩을 사용할 수 있다.

### OSIV의 단점

#### 데이터베이스 커넥션 풀 소진

API에 포함된 코드 중에 데이터베이스와 관련이 없는 코드가 시간을 오래 끈다면 다음과 같은 문제가 발생한다.

- API가 응답할 때까지 데이터베이스의 커넥션을 잡아둠
- 그런 요청이 많이 들어오게 된다면 순식간에 데이터베이스 커넥션 풀은 소진
- 다음 요청을 처리할 수 없는 상태가 됨

#### 영속성 컨텍스트 공유 문제

트랜잭션 단위로 영속성 컨텍스트를 열던 것을 요청 단위로 영속성 컨텍스트를 여는 것으로 확장했다.

- 하나의 요청에서 여러 트랜잭션이 있을 경우 영속성 컨텍스트를 공유
- 의도하지 않은 데이터 변경 가능성 존재

## 결론

영속성 컨텍스트는 애플리케이션과 데이터베이스 사이에 존재하는 가상의 데이터베이스이다. 1차 캐시를 통해 데이터베이스 접근 횟수를 감소시키고 동일성을 보장한다.

1차 캐시는 트랜잭션 단위로 동작하며 같은 엔티티를 반복 조회할 때 데이터베이스를 조회하지 않고 캐시된 엔티티를 반환한다. 애플리케이션 수준에서 REPEATABLE READ 수준의 트랜잭션 격리를 제공한다.

쓰기 지연 기능은 트랜잭션 커밋 직전까지 SQL을 모아서 한 번에 데이터베이스로 전송하여 배치 처리를 가능하게 한다. hibernate.default_batch_fetch_size 설정을 통해 성능을 최적화할 수 있다.

스프링은 기본적으로 트랜잭션 범위 영속성 컨텍스트 전략을 사용한다. OSIV 패턴은 뷰까지 영속성 컨텍스트를 유지하여 지연 로딩을 가능하게 하지만 커넥션 풀 소진과 영속성 컨텍스트 공유 문제가 발생할 수 있으므로 신중하게 사용해야 한다.
