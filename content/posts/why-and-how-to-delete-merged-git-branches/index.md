---
title: "Merge 후 브랜치 삭제: 왜 그리고 어떻게"
date: 2024-07-11T22:27:22+09:00
tags: ["git", "version control", "collaboration"]
description: "Git 브랜치의 생성부터 삭제까지 전체 라이프사이클을 이해하고, 병합된 브랜치를 안전하게 확인하고 삭제하는 방법과 자동화 스크립트, GitHub/GitLab의 자동 삭제 설정, 그리고 실수로 삭제한 브랜치를 복구하는 방법까지 포괄적으로 다룬다."
draft: false
---

## Merge 과정 상세 설명

1. **새 브랜치 생성**:
   메인 브랜치에서 `git checkout -b <new-branch-name>`으로 새 브랜치를 만든다.

2. **브랜치에 커밋 추가**:
   새 브랜치에서 코드를 변경하고 의미 있는 단위로 커밋한다.

3. **원격 저장소에 push**:
   `git push origin <branch-name>`으로 작업한 브랜치를 원격에 업로드한다.

4. **Pull request 생성**:
   GitHub 등에서 pull request를 만들어 변경사항 병합을 요청한다.

5. **코드 리뷰 진행**:
   팀원들이 코드를 검토하고 필요시 수정을 요청한다.

6. **Merge 실행**:
   리뷰 완료 후 pull request를 메인 브랜치에 병합한다.

이 과정을 통해 팀은 코드 품질을 유지하며 효율적으로 협업할 수 있다. 프로젝트 특성에 따라 각 단계를 조정하거나 자동화할 수 있다.

## 브랜치 라이프사이클

브랜치는 생성, 사용, 병합, 삭제의 명확한 라이프사이클을 가지며, 각 단계에서 적절한 관리가 필요하고, 이를 통해 저장소의 복잡도를 낮추고 협업 효율성을 높일 수 있다.

### 단명 브랜치 vs 장명 브랜치

브랜치는 수명에 따라 두 가지 유형으로 분류되며, 각각의 특성과 용도가 다르고, 프로젝트의 워크플로우에 따라 적절히 혼용하여 사용한다.

**단명 브랜치(Short-lived branches)**는 특정 작업을 위해 생성되어 빠르게 병합되고 삭제되는 브랜치로, Feature 브랜치와 Hotfix 브랜치가 이에 해당하며, 일반적으로 며칠에서 몇 주 내에 생명 주기가 완료되고, 병합 후 즉시 삭제하는 것이 권장된다.

**장명 브랜치(Long-lived branches)**는 프로젝트 전체 기간 동안 유지되는 브랜치로, main, master, develop, production 등이 이에 해당하며, 지속적으로 업데이트되고 여러 단명 브랜치들의 병합 대상이 되며, 절대 삭제하지 않는다.

### 브랜치 유형별 수명 주기

**Feature 브랜치**는 새로운 기능 개발을 위해 생성되며, develop 또는 main 브랜치에서 분기하고, 기능 완료 후 코드 리뷰를 거쳐 병합되며, 병합 즉시 삭제하여 저장소를 깔끔하게 유지한다.

**Release 브랜치**는 배포 준비를 위해 생성되며, develop 브랜치에서 분기하고, 버전 관련 작업과 버그 수정을 진행하며, 배포 완료 후 main과 develop 양쪽에 병합되고 삭제된다.

**Hotfix 브랜치**는 프로덕션 긴급 버그 수정을 위해 생성되며, main 브랜치에서 직접 분기하고, 수정 완료 후 main과 develop 양쪽에 병합되며, 병합 후 즉시 삭제된다.

## Merge 후 브랜치를 삭제해야 하는 이유

Merge 후 브랜치를 삭제하는 것은 여러 가지 중요한 이점을 제공한다. 우선, 저장소를 깔끔하게 유지하고 혼란을 방지하여 개발 과정을 더 명확하게 만든다. 또한 Git 작업의 성능을 향상하고, 작업 주기의 완료를 명확히 표시하여 워크플로우 관리를 돕는다.

불필요한 브랜치를 제거함으로써 실수로 오래된 브랜치에 커밋하는 것을 방지하고, 저장 공간을 절약할 수 있다. 이는 프로젝트의 Git 히스토리를 더욱 깔끔하게 만들어 이력 관리를 용이하게 한다.

팀 협업 측면에서도, 브랜치 삭제는 작업 완료의 신호 역할을 하며 커뮤니케이션을 개선한다. 보안 면에서는 오래된 코드에 대한 접근을 제한하여 잠재적 위험을 줄일 수 있다.

마지막으로, 활성 브랜치 수를 최소화함으로써 개발자들이 현재 진행 중인 작업에 더 집중할 수 있게 하여 전반적인 생산성 향상에 기여한다.

## 삭제 전 확인사항

브랜치를 삭제하기 전에 반드시 병합 상태를 확인해야 하며, 이를 통해 병합되지 않은 작업을 실수로 잃어버리는 것을 방지할 수 있고, Git은 이를 위한 다양한 명령어를 제공한다.

### 병합된 브랜치 확인

현재 브랜치에 이미 병합된 브랜치 목록을 확인하려면 `git branch --merged` 명령어를 사용하며, 이 명령어는 현재 브랜치에 완전히 병합되어 안전하게 삭제할 수 있는 브랜치들을 표시한다.

```bash
git branch --merged
```

반대로 아직 병합되지 않은 브랜치를 확인하려면 `git branch --no-merged` 명령어를 사용하며, 이 브랜치들은 고유한 커밋을 가지고 있어 삭제 시 주의가 필요하다.

```bash
git branch --no-merged
```

특정 브랜치를 기준으로 병합 상태를 확인할 수도 있으며, 예를 들어 main 브랜치에 병합된 브랜치를 확인하려면 다음과 같이 실행한다.

```bash
git branch --merged main
```

### 로컬과 원격 브랜치 상태 확인

로컬 브랜치와 원격 브랜치의 동기화 상태를 확인하는 것도 중요하며, 원격 브랜치 목록을 보려면 `-r` 옵션을 사용하고, 모든 브랜치를 보려면 `-a` 옵션을 사용한다.

```bash
# 원격 브랜치 목록
git branch -r

# 로컬과 원격 브랜치 모두 표시
git branch -a
```

특정 브랜치의 원격 추적 상태를 확인하려면 `-vv` 옵션을 사용하며, 이를 통해 로컬 브랜치가 어떤 원격 브랜치를 추적하고 있는지, 그리고 얼마나 앞서거나 뒤처져 있는지 확인할 수 있다.

```bash
git branch -vv
```

### 병합되지 않은 커밋 확인

브랜치 간의 차이를 확인하여 병합되지 않은 커밋이 있는지 검토할 수 있으며, 이를 위해 `git log` 명령어를 활용한다.

```bash
# feature 브랜치에만 있고 main에 없는 커밋 확인
git log main..feature

# 양방향 차이 확인
git log main...feature
```

## Merge 후 브랜치 삭제 방법

### 로컬 브랜치 삭제 명령어

Git은 로컬 브랜치를 삭제하기 위해 두 가지 옵션을 제공하며, 각각의 용도와 안전성 수준이 다르고, 상황에 맞게 선택하여 사용해야 한다.

**안전한 삭제 (`-d` 옵션)**는 병합이 완료된 브랜치만 삭제하는 옵션으로, 병합되지 않은 커밋이 있으면 삭제를 거부하여 데이터 손실을 방지하며, 일반적으로 권장되는 방법이다.

```bash
git branch -d <branch-name>
```

병합되지 않은 브랜치를 삭제하려고 하면 다음과 같은 오류 메시지가 표시되며, 이는 브랜치에 아직 병합되지 않은 작업이 있음을 의미한다.

```bash
error: The branch 'feature-branch' is not fully merged.
If you are sure you want to delete it, run 'git branch -D feature-branch'.
```

**강제 삭제 (`-D` 옵션)**는 병합 여부와 관계없이 브랜치를 강제로 삭제하는 옵션으로, 병합되지 않은 커밋이 있어도 삭제되며, 삭제 후 복구가 어려울 수 있으므로 신중하게 사용해야 한다.

```bash
git branch -D <branch-name>
```

이 명령어는 실험적 브랜치나 더 이상 필요하지 않은 작업을 폐기할 때 유용하지만, 중요한 작업이 포함되어 있지 않은지 반드시 확인해야 한다.

### 원격 브랜치 삭제

원격 저장소의 브랜치를 삭제하는 방법은 여러 가지가 있으며, 가장 일반적으로 사용되는 방법은 `git push` 명령어를 사용하는 것이고, 이는 로컬 삭제와는 독립적으로 수행되어야 한다.

```bash
# 표준 방법
git push origin --delete <branch-name>

# 대체 문법 (동일한 기능)
git push origin :<branch-name>
```

원격 브랜치를 삭제하면 해당 브랜치는 원격 저장소에서 제거되지만, 다른 개발자의 로컬 저장소에는 여전히 추적 브랜치가 남아 있을 수 있으며, 이를 정리하려면 별도의 명령어가 필요하다.

### 로컬 저장소의 원격 브랜치 참조 정리

원격에서 삭제된 브랜치의 로컬 참조를 정리하는 것은 저장소를 깔끔하게 유지하는 데 중요하며, `git fetch` 명령어의 `--prune` 옵션을 사용하여 오래된 원격 추적 브랜치를 제거할 수 있다.

```bash
# 모든 원격 저장소의 최신 상태를 가져오고 삭제된 브랜치 참조 제거
git fetch --all -p

# 또는 특정 원격 저장소만 대상으로 실행
git fetch origin --prune
```

`--prune` 옵션은 원격 저장소에 더 이상 존재하지 않는 브랜치에 대한 로컬 참조를 자동으로 삭제하며, 이를 통해 `git branch -r` 명령어로 확인되는 원격 브랜치 목록을 최신 상태로 유지할 수 있다.

자동으로 prune을 실행하도록 Git 설정을 변경할 수도 있으며, 이렇게 하면 매번 fetch 실행 시 자동으로 정리가 이루어진다.

```bash
git config --global fetch.prune true
```

## 대량 브랜치 삭제 자동화

프로젝트가 진행되면서 병합된 브랜치가 누적되면 일일이 수동으로 삭제하는 것이 번거로울 수 있으며, 이런 경우 스크립트를 활용하여 브랜치를 일괄적으로 정리할 수 있고, 이는 정기적인 유지보수 작업에 매우 유용하다.

### 병합된 로컬 브랜치 일괄 삭제

현재 브랜치에 병합된 모든 로컬 브랜치를 삭제하는 스크립트는 main, master, develop 같은 중요 브랜치를 보호하면서 안전하게 정리할 수 있으며, 다음과 같이 작성할 수 있다.

```bash
# main을 제외한 병합된 브랜치 삭제
git branch --merged | grep -v "\*" | grep -v "main" | grep -v "master" | grep -v "develop" | xargs -n 1 git branch -d
```

이 명령어는 `git branch --merged`로 병합된 브랜치 목록을 가져오고, `grep -v`로 main, master, develop 브랜치를 제외하며, `xargs`를 사용하여 각 브랜치를 삭제한다.

더 안전한 방식으로 삭제 전에 확인을 요청하는 스크립트를 만들 수도 있으며, 이를 통해 실수로 중요한 브랜치를 삭제하는 것을 방지할 수 있다.

```bash
# 삭제할 브랜치 목록 미리 확인
git branch --merged | grep -v "\*" | grep -v "main" | grep -v "master" | grep -v "develop"

# 확인 후 실행
git branch --merged | grep -v "\*" | grep -v "main" | grep -v "master" | grep -v "develop" | xargs -n 1 -p git branch -d
```

`-p` 옵션을 추가하면 각 브랜치를 삭제하기 전에 확인을 요청하며, y/n으로 응답하여 선택적으로 삭제할 수 있다.

### 원격에서 삭제된 브랜치의 로컬 추적 브랜치 정리

원격 저장소에서 삭제된 브랜치에 대한 로컬 추적 브랜치를 찾아서 삭제하는 스크립트는 다음과 같이 작성할 수 있으며, 이는 prune 후에도 남아 있는 로컬 브랜치를 정리하는 데 유용하다.

```bash
# 원격 추적이 끊긴 로컬 브랜치 찾기 및 삭제
git fetch -p && git branch -vv | grep ': gone]' | awk '{print $1}' | xargs git branch -D
```

이 명령어는 먼저 `git fetch -p`로 원격 브랜치 참조를 정리하고, `git branch -vv`로 추적 상태를 확인하며, `gone`으로 표시된 브랜치들을 찾아 삭제한다.

## 브랜치 삭제 시 주의사항

브랜치 삭제는 되돌리기 어려운 작업이므로 신중하게 진행해야 하며, 몇 가지 중요한 주의사항을 염두에 두고 작업하면 실수를 방지할 수 있고, 팀의 워크플로우를 안전하게 유지할 수 있다.

### 메인 브랜치 보호

main, master, develop, production 같은 장명 브랜치는 프로젝트의 핵심 브랜치로 절대 삭제해서는 안 되며, 실수로 삭제하는 것을 방지하기 위해 Git 브랜치 보호 규칙을 설정하거나 스크립트에서 명시적으로 제외해야 한다.

GitHub이나 GitLab 같은 플랫폼에서는 브랜치 보호 규칙을 설정하여 특정 브랜치의 삭제, 강제 푸시, 직접 커밋을 방지할 수 있으며, 이는 저장소 설정에서 구성할 수 있다.

### 팀원들과 커뮤니케이션

원격 브랜치를 삭제하기 전에 해당 브랜치에서 작업 중인 팀원이 없는지 확인해야 하며, 특히 공유 브랜치나 다른 팀원이 사용할 가능성이 있는 브랜치는 팀과 논의 후 삭제하는 것이 좋고, 갑작스러운 삭제는 협업에 혼란을 줄 수 있다.

### 백업이 필요한 경우 태그 사용

삭제하려는 브랜치의 작업을 나중에 참조해야 할 가능성이 있다면 브랜치를 삭제하기 전에 태그를 생성하여 백업할 수 있으며, 태그는 특정 커밋을 가리키는 불변의 참조로 브랜치가 삭제되어도 유지된다.

```bash
# 브랜치 삭제 전 태그 생성
git tag archive/feature-name feature-name
git push origin archive/feature-name

# 이후 브랜치 삭제
git branch -d feature-name
git push origin --delete feature-name
```

이렇게 하면 브랜치는 삭제되지만 해당 시점의 코드는 태그를 통해 언제든 접근할 수 있으며, 필요시 태그에서 새 브랜치를 생성하여 작업을 재개할 수 있다.

## GitHub/GitLab 자동 삭제 설정

GitHub과 GitLab은 Pull Request 또는 Merge Request가 병합된 후 자동으로 브랜치를 삭제하는 기능을 제공하며, 이를 활용하면 수동으로 브랜치를 정리하는 수고를 덜 수 있고, 저장소를 자동으로 깔끔하게 유지할 수 있다.

### GitHub 자동 삭제 설정

GitHub에서는 저장소 설정에서 Pull Request 병합 후 자동으로 head 브랜치를 삭제하는 옵션을 활성화할 수 있으며, 이는 저장소별로 설정되고, 개별 PR에서도 병합 시 선택할 수 있다.

1. 저장소의 Settings 탭으로 이동한다.
2. General 섹션에서 "Automatically delete head branches" 옵션을 활성화한다.
3. 이제 PR이 병합될 때마다 자동으로 소스 브랜치가 삭제된다.

개별 PR 병합 시에도 "Delete branch" 버튼이 자동으로 표시되며, 이를 클릭하여 수동으로 삭제하거나 자동 설정을 활성화하면 병합과 동시에 삭제된다.

### GitLab 자동 삭제 설정

GitLab에서도 유사한 기능을 제공하며, Merge Request 생성 시 또는 프로젝트 설정에서 병합 후 소스 브랜치 삭제 옵션을 활성화할 수 있고, 이는 프로젝트 전체에 적용되거나 개별 MR에서 선택할 수 있다.

1. 프로젝트의 Settings > Merge requests로 이동한다.
2. "Enable 'Delete source branch' option by default" 옵션을 활성화한다.
3. 이제 MR 생성 시 기본적으로 체크박스가 선택되어 있다.

### 자동화의 장단점

자동 브랜치 삭제는 관리 부담을 줄이고 저장소를 깔끔하게 유지하는 장점이 있지만, 모든 상황에 적합한 것은 아니며, 프로젝트의 워크플로우와 팀의 작업 방식을 고려하여 결정해야 한다.

**장점**으로는 수동 삭제 작업 불필요, 저장소 자동 정리, 브랜치 라이프사이클의 명확한 종료, 실수로 오래된 브랜치에 커밋하는 것 방지 등이 있다.

**단점**으로는 브랜치를 보관하고 싶은 경우 불편함, 자동 삭제 전 백업하지 못한 경우 복구 필요, 팀원들이 아직 로컬에서 작업 중일 수 있음 등이 있으며, 이런 경우 자동 삭제를 비활성화하거나 선택적으로 사용하는 것이 좋다.

## 삭제된 브랜치 복구 방법

실수로 브랜치를 삭제했거나 삭제 후 필요한 작업이 있음을 발견한 경우 Git의 reflog 기능을 사용하여 삭제된 브랜치를 복구할 수 있으며, reflog는 HEAD의 모든 이동 기록을 저장하므로 최근 작업을 되돌리는 데 유용하다.

### reflog를 이용한 복구

`git reflog` 명령어는 로컬 저장소에서 발생한 모든 참조 변경 사항을 시간순으로 보여주며, 이를 통해 삭제된 브랜치의 마지막 커밋 해시를 찾을 수 있고, 해당 커밋에서 새 브랜치를 생성하여 복구할 수 있다.

```bash
# reflog 확인
git reflog

# 출력 예시
a1b2c3d HEAD@{0}: checkout: moving from feature-branch to main
e4f5g6h HEAD@{1}: commit: Add new feature
i7j8k9l HEAD@{2}: commit: Fix bug
```

삭제된 브랜치의 마지막 커밋 해시를 찾았다면 해당 해시에서 새 브랜치를 생성하여 복구할 수 있으며, 브랜치 이름은 원래 이름과 동일하게 하거나 다른 이름으로 지정할 수 있다.

```bash
# 삭제된 브랜치를 커밋 해시에서 복구
git checkout -b feature-branch e4f5g6h

# 또는 기존 브랜치 이름으로 복구
git branch feature-branch e4f5g6h
```

### 삭제된 원격 브랜치 복구

원격 브랜치가 삭제된 경우 로컬에 해당 브랜치가 남아 있다면 다시 푸시하여 복구할 수 있으며, 로컬에도 없다면 다른 팀원의 로컬 저장소에서 가져오거나 reflog를 통해 복구해야 한다.

```bash
# 로컬에 브랜치가 남아 있는 경우 원격으로 다시 푸시
git push origin feature-branch

# 로컬에도 없는 경우 reflog로 찾아 복구 후 푸시
git checkout -b feature-branch e4f5g6h
git push origin feature-branch
```

reflog는 기본적으로 90일간 기록을 유지하므로 최근에 삭제된 브랜치는 복구 가능하지만, 시간이 오래 지나면 기록이 정리되어 복구가 어려울 수 있으며, 중요한 작업은 삭제 전 반드시 확인해야 한다.

## 팀 워크플로우와의 통합

브랜치 삭제 정책은 팀의 Git 워크플로우와 통합되어야 효과적이며, 브랜치 네이밍 규칙, 삭제 시기, 책임자 지정 등을 명확히 정의하면 혼란을 방지하고 효율적인 협업이 가능하다.

### 브랜치 네이밍 규칙과 삭제 정책

일관된 브랜치 네이밍 규칙은 브랜치의 목적과 수명을 명확히 하며, 이를 통해 어떤 브랜치를 삭제해야 하는지 쉽게 판단할 수 있고, 자동화 스크립트 작성에도 도움이 된다.

```bash
# 네이밍 규칙 예시
feature/user-authentication    # 기능 개발 - 병합 후 삭제
bugfix/login-error            # 버그 수정 - 병합 후 삭제
hotfix/security-patch         # 긴급 수정 - 병합 후 삭제
release/v1.2.0                # 릴리스 준비 - 배포 후 삭제
experiment/new-architecture   # 실험적 작업 - 결정 후 삭제 또는 보관
```

각 브랜치 유형별로 삭제 정책을 정의하면 팀원들이 일관되게 브랜치를 관리할 수 있으며, 예를 들어 feature와 bugfix는 병합 즉시 삭제, release는 배포 완료 후 삭제, experiment는 팀 논의 후 결정하는 식으로 규칙을 만들 수 있다.

### 정기적인 브랜치 정리 일정

정기적으로 브랜치를 검토하고 정리하는 일정을 팀 프로세스에 포함시키면 저장소가 지저분해지는 것을 방지할 수 있으며, 스프린트 종료 시, 릴리스 후, 또는 매월 정해진 날짜에 브랜치 정리 작업을 수행하는 것이 좋다.

정리 작업 시에는 병합된 브랜치 목록을 확인하고, 필요한 경우 태그를 생성하며, 자동화 스크립트를 실행하여 일괄 삭제하고, 팀원들에게 정리 내역을 공유하는 순서로 진행할 수 있다.

```bash
# 정기 정리 스크립트 예시
#!/bin/bash

echo "=== Branch Cleanup Report ==="
echo "Date: $(date)"
echo ""

echo "Merged branches to be deleted:"
git branch --merged main | grep -v "\*" | grep -v "main" | grep -v "master" | grep -v "develop"

echo ""
echo "Proceeding with deletion..."
git branch --merged main | grep -v "\*" | grep -v "main" | grep -v "master" | grep -v "develop" | xargs -n 1 git branch -d

echo ""
echo "Pruning remote references..."
git fetch --all -p

echo ""
echo "Cleanup completed!"
```

이런 스크립트를 팀의 문서화된 프로세스에 포함시키고 정기적으로 실행하면 저장소를 일관되게 깔끔하게 유지할 수 있으며, CI/CD 파이프라인에 통합하여 자동화할 수도 있다.

## 결론

정기적인 브랜치 관리는 효율적인 Git 워크플로우의 핵심이며, 브랜치의 라이프사이클을 이해하고, 병합 상태를 확인하며, 적절한 삭제 명령어를 사용하고, 자동화를 활용하면 저장소를 깔끔하게 유지하고 팀 협업을 원활하게 할 수 있다. 삭제 시 주의사항을 염두에 두고, 필요한 경우 복구 방법을 알고 있으면 실수를 두려워하지 않고 자신 있게 브랜치를 관리할 수 있으며, 팀의 워크플로우에 브랜치 삭제 정책을 통합하면 더욱 체계적이고 효율적인 버전 관리가 가능해진다.
