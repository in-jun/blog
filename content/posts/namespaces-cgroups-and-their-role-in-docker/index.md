---
title: "namespace, cgroups 그리고 docker와의 관계"
date: 2024-06-05T21:59:22+09:00
tags: ["linux", "docker"]
description: "Linux 커널의 컨테이너 기술 발전사, 7가지 namespace 종류 상세 설명(PID, Network, Mount, IPC, UTS, User, Cgroup), cgroups v1 vs v2 차이, Docker의 격리 메커니즘 구현 방식, 실제 명령어로 확인하는 자원 관리, 보안 측면에서의 한계와 해결책까지 정리"
draft: false
---

## Linux 컨테이너 기술의 역사

### Namespace의 탄생

Linux namespace는 2002년 커널 2.4.19에서 mount namespace에 대한 작업으로 처음 시작되었다. Bell Labs의 Plan 9에서 널리 사용된 namespace 기능에서 영감을 받았다.

### 주요 발전 과정

2006년부터 추가적인 namespace들이 계속해서 추가되었다.

- **2007년 7월**: PID namespace 도입
- **2007년 9월**: NET namespace 추가
- **2008년 2월**: memory cgroups 등장
- **커널 3.8**: User namespace 도입으로 적절한 컨테이너 지원 기능 완성

현재 커널 버전 5.6 이후로는 8종류의 namespace가 존재한다.

### 컨테이너 기술의 발전

LXC(Linux Containers)는 2008년 리눅스 커널의 cgroups와 namespace 기능을 활용하는 도구를 제공했다. Docker는 2013년에 커널 cgroups와 namespace를 통한 프로세스 격리와 함께 이름이 지정된 이미지를 빌드하고 가져오는 도구를 결합하여 등장했다.

### Namespace의 역할

Namespace는 Linux에서 컨테이너가 작동하는 데 필수적인 측면이다. 리눅스 커널의 기능으로 커널 자원을 분할하여 한 프로세스 집합은 한 자원 집합을 보고 다른 프로세스 집합은 다른 자원 집합을 볼 수 있도록 한다.

가상 머신에서는 하드웨어를 가상화하지만 namespace는 커널의 기능을 분할한다.

## Namespace의 개념과 역할

Namespace는 프로세스가 자원을 공유하지 않도록 분리하는 기술이다. 가상 머신보다 가볍고 빠르다.

### 자원 격리 메커니즘

Namespace는 시스템 자원을 격리하는 메커니즘을 제공한다. namespace 내의 프로세스가 프로세스 ID, 네트워크 인터페이스, 파일 시스템과 같은 시스템의 자체 뷰를 가질 수 있도록 한다.

커널의 기능을 분할하여 충돌을 방지하고 프로세스 간의 자원 공유를 제한한다.

### 컨테이너와의 관계

Docker와 같은 다양한 컨테이너 소프트웨어는 Linux namespace를 cgroups와 결합하여 프로세스를 격리한다. namespace는 격리를 수행하여 한 프로세스가 다른 프로세스나 시스템에 접근하거나 영향을 미치는 것을 방지하는 별도의 환경을 생성한다.

### Namespace와 Cgroups의 역할 구분

- **Namespace**: 격리를 생성하여 프로세스가 분리된 환경에서 실행될 수 있도록 함
- **Cgroups**: 프로세스 그룹 간에 CPU, 메모리, I/O와 같은 자원을 분배하고 제한

컨테이너화에서는 너무 많은 자원을 사용하여 동일한 호스트의 다른 컨테이너 성능을 저하시키는 noisy neighbor의 위험을 줄이는 데 사용된다.

## 7가지 Namespace 종류 상세 설명

Linux 커널 v4.4.0은 7가지 유형의 namespace를 제공한다. cgroup, pid, net, mnt, uts, ipc, user가 있다. 최신 커널(Linux 6.1.0+)에는 time namespace도 포함되어 총 8가지 유형이 된다.

### PID Namespace

프로세스 ID를 격리하여 별도의 PID 번호 시퀀스를 제공한다.

PID namespace에서 생성된 첫 번째 프로세스는 프로세스 ID 번호 1을 할당받는다. 일반 init 프로세스와 동일한 특별 대우를 받으며 namespace 내의 고아 프로세스가 여기에 연결된다.

이 PID 1 프로세스의 종료는 해당 PID namespace와 모든 하위 항목의 모든 프로세스를 즉시 종료시킨다.

### Network Namespace

네트워크 스택을 가상화한다. 각 namespace는 독립적인 네트워크 환경을 가진다.

- **IP 주소 집합**: 고유한 IP 주소 할당
- **라우팅 테이블**: 독립적인 라우팅 규칙
- **소켓 목록**: 격리된 소켓 연결
- **방화벽**: 독립적인 방화벽 규칙

생성 시 네트워크 namespace에는 루프백 인터페이스만 포함된다. 각 네트워크 인터페이스(물리적 또는 가상)는 정확히 1개의 namespace에 존재하며 namespace 간에 이동할 수 있다.

### Mount Namespace (MNT)

namespace의 프로세스가 보는 독립적인 마운트 포인트 목록을 가진다. 호스트 파일 시스템에 영향을 주지 않고 mount namespace에서 파일 시스템을 마운트하고 언마운트할 수 있다.

프로세스에 격리된 파일 시스템 뷰를 제공하여 프로세스가 호스트의 다른 프로세스에 속한 파일을 방해하지 않도록 보장하는 데 유용하다.

### IPC Namespace (Inter-Process Communication)

System V IPC와 POSIX 메시지 큐를 격리한다.

격리되는 프로세스 통신 메커니즘은 다음과 같다.

- **세마포어**: 프로세스 간 동기화
- **메시지 큐**: 프로세스 간 메시지 전달
- **공유 메모리 세그먼트**: 프로세스 간 메모리 공유

### UTS Namespace (UNIX Time-Sharing)

단일 시스템이 다른 프로세스에 대해 다른 호스트 및 도메인 이름을 가진 것처럼 보이도록 허용한다. 호스트 이름과 NIS 도메인 이름을 격리한다.

프로세스가 사용하는 호스트 이름을 설정하므로 컨테이너가 기본 VM과 다른 호스트 이름을 갖는 이유이다.

### User Namespace

커널 3.8 이후 사용 가능한 여러 프로세스 집합에 대한 권한 격리와 사용자 식별 분리를 제공하는 기능이다.

컨테이너 관점에서 시스템 관점으로 사용자 ID를 변환하는 매핑 테이블을 포함한다. 예를 들어 루트 사용자가 컨테이너에서 사용자 ID 0을 가질 수 있지만 소유권 검사를 위해 시스템에서는 실제로 사용자 ID 1,400,000으로 처리된다.

컨테이너 내부의 사용자 ID를 호스트의 다른 사용자 ID에 매핑하여 추가 보안 계층을 추가한다. 이는 컨테이너 내부에서 루트 사용자로 실행되는 프로세스가 호스트에서 루트 권한을 갖지 않음을 의미한다.

이 기능은 공격자가 컨테이너를 탈출하여 호스트 시스템에 대한 제어권을 얻으려는 컨테이너 탈출 공격의 위험을 크게 줄인다.

### Cgroup Namespace

cgroup 루트 디렉토리와 계층 구조 뷰를 격리하여 컨테이너에 격리된 cgroup 계층 구조 뷰를 제공한다. 컨테이너에 자체 격리된 cgroups를 제공한다.

## Namespace 사용 방법

### 주요 시스템 콜

Namespace를 사용하는 주요 방법은 다음과 같다.

- **unshare**: 현재 프로세스의 namespace를 분리
- **setns**: 다른 프로세스의 namespace에 참여
- **clone**: 새로운 프로세스를 생성하면서 namespace를 지정

### Docker에서의 사용

Docker는 컨테이너를 생성할 때 기본적으로 mnt, uts, ipc, pid, net namespace를 사용한다. 컨테이너가 시작되면 Docker는 해당 컨테이너에 특별히 할당된 고유한 namespace 및 cgroups 세트를 생성한다.

### Runc의 역할

Runc는 Linux 커널의 컨테이너 기능(namespace, cgroups 등)과 직접 인터페이스하여 각 컨테이너에 대한 격리된 환경을 만든다. namespace와 cgroups는 프로세스 격리와 자원 관리를 위해 함께 사용되는 경우가 많다.

## cgroups의 개념과 구성

cgroups(Control groups)는 리눅스 커널의 기능으로 프로세스 그룹을 생성하고 이 그룹에 리소스를 할당하고 관리하는 기능이다. Linux 시스템에서 프로세스의 자원 사용을 제어하는 데 도움이 되도록 설계되었다.

### 자원 분배와 제한

cgroups는 프로세스 그룹 간에 CPU, 메모리, I/O와 같은 자원을 분배하고 제한한다. 이를 통해 여러 프로세스의 동시 실행을 제어하고 리소스의 사용을 제한하거나 우선순위를 지정할 수 있다.

### 주요 구성 요소

cgroups의 주요 구성 요소는 다음과 같다.

- **CPU**: CPU 시간 할당
- **Memory**: 메모리 사용량 제한
- **Block I/O**: 블록 장치의 I/O 트래픽 제어
- **Network**: 네트워크 대역폭 제한

### Cgroup Namespace의 도입 배경

전통적으로 프로세스에 할당된 cgroups는 namespace화되지 않았기 때문에 프로세스에 대한 정보가 한 컨테이너에서 다른 컨테이너로 누출될 위험이 있었다. 이로 인해 컨테이너에 자체 격리된 cgroups를 제공하는 cgroup namespace가 도입되었다.

## cgroups v1 vs v2 차이

### 계층 구조의 변화

cgroups v1은 여러 계층을 가졌던 것과 달리 v2는 단일 통합 계층을 사용한다. cgroups v2는 모든 컨트롤러가 마운트되는 통합 계층을 제공한다.

cgroups v1은 CPU, 메모리, 블록 I/O 및 기타 자원에 대해 별도의 계층에서 서로 다른 자원 컨트롤러가 작동하도록 허용했다. v1과 달리 cgroup v2에는 단일 프로세스 계층만 있다.

컨트롤러는 하나의 계층에만 할당될 수 있기 때문에 별도의 계층에 있는 프로세스는 동일한 컨트롤러로 관리할 수 없었다. 이 변경으로 문제가 해결되었으며 자원 관리를 단순화하고 시스템 전체의 일관성을 향상시킨다.

### 프로세스 연결 규칙

cgroups v1에서는 리프가 아닌 노드에도 프로세스를 연결할 수 있었다. cgroups v2에서는 활성화된 컨트롤러가 있는 경우 내부 하위 그룹에 프로세스를 연결할 수 없으며 리프에만 프로세스를 연결할 수 있다.

### 스레드 관리

cgroups v1에서는 동일한 프로세스의 스레드를 다른 cgroups에 할당할 수 있었다. cgroups v2에서는 불가능하다.

스레드를 구별하는 기능을 제거하고 대신 프로세스 단위로 작동하도록 선택했다.

### v2 도입 배경

V1 구현의 복잡성과 V1 내 제한의 불일치로 인해 V2가 만들어졌다. CGroup 계층을 단순화하고 하위 시스템 전체에서 CGroup 작업을 일관되게 유지하기 위함이다.

### 업계 동향

Kubernetes는 cgroup v1을 더 이상 사용하지 않는다. 제거는 Kubernetes 지원 중단 정책을 따르며, 커뮤니티는 v1.31에서 cgroup v1 지원을 유지 보수 모드로 전환하기로 결정했다.

### RHEL 버전별 지원

- **RHEL 6과 7**: 역사적으로 CGroups V1만 구현
- **RHEL 8과 9**: CGroups V1과 V2 모두 사용 가능하며 V1이 기본값
- **RHEL 10**: CGroups V2만 사용 가능

## Docker에서 namespace와 cgroups 사용

Docker는 컨테이너 기술을 활용하여 애플리케이션의 배포와 관리를 단순화하는 도구이다. 도커 컨테이너는 namespace와 cgroups 기능을 사용하여 애플리케이션을 격리된 환경에서 실행한다.

### Namespace 활용

Docker에서 사용하는 주요 namespace는 다음과 같다.

- **PID namespace**: 각 컨테이너가 독립된 프로세스 공간을 가지며 호스트와 다른 PID namespace에서 실행
- **Network namespace**: 컨테이너가 독립된 네트워크 스택을 가지며 IP 주소, 라우팅 테이블 등을 호스트와 분리
- **Mount namespace**: 각 컨테이너가 독립된 파일 시스템 뷰를 가지며 호스트 파일 시스템과 분리된 파일 시스템 트리를 구성

### Cgroups 활용

Docker는 cgroups를 사용하여 각 컨테이너에 리소스를 할당하고 제한할 수 있다.

제어 가능한 리소스는 다음과 같다.

- **CPU**: 프로세서 사용량 제한
- **메모리**: RAM 사용량 제한
- **디스크 I/O**: 디스크 입출력 속도 제한

cgroups를 통해 각 컨테이너의 리소스 사용량을 모니터링하고 관리할 수 있다.

### 추상화와 사용 편의성

Docker는 리눅스의 cgroups와 namespace를 추상화하여 사용자가 쉽게 컨테이너를 생성하고 관리할 수 있도록 한다. 복잡한 cgroups와 namespace 설정을 신경 쓰지 않고 단순한 명령어로 컨테이너를 관리할 수 있다.

Docker 명령어 `docker run`을 사용하면 자동으로 필요한 namespace와 cgroups가 설정되고 컨테이너가 실행된다.

## 격리 메커니즘 확인 방법

Linux의 namespace와 cgroups는 Docker의 핵심 기술로 Docker 컨테이너의 격리성과 리소스 관리 기능을 지원한다. 이를 통해 애플리케이션의 배포, 확장 및 관리를 효율적으로 할 수 있다.

### 시스템 레벨 확인

실제로 namespace와 cgroups를 확인하는 방법은 다음과 같다.

- **`lsns` 명령어**: 현재 시스템의 namespace 확인
- **`/proc/<PID>/ns/` 디렉토리**: 특정 프로세스의 namespace 정보 확인
- **`/sys/fs/cgroup/` 디렉토리**: cgroups 설정 확인

### Docker 컨테이너 확인

Docker 컨테이너의 격리 메커니즘을 확인하는 명령어는 다음과 같다.

- **`docker inspect <container_id>`**: 컨테이너의 namespace와 cgroups 설정 확인
- **`docker exec <container_id> ps aux`**: 격리된 프로세스 목록 확인
- **`docker stats <container_id>`**: 실시간 리소스 사용량 모니터링

## 보안 측면의 한계

### 공유 커널의 문제

컨테이너는 서로 그리고 호스트로부터 격리되어 있지만 여전히 동일한 커널을 공유한다. Linux에서 namespace, cgroups, seccomp 필터는 함께 작동하여 격리의 외관을 만들지만 모두 동일한 커널 위에서 실행된다.

해당 커널이 손상되면 공유 커널 취약점으로 인해 경계가 무너진다. 점점 인기를 얻고 있는 말처럼 "컨테이너는 격리하지 않는다"는 것이며, 이는 컨테이너 격리의 근본적인 한계를 나타낸다.

### 리소스 고갈 공격

기본적으로 Linux 프로세스와 이후 컨테이너는 생성할 수 있는 프로세스 수에 제한을 두지 않는다. 이는 리소스 고갈 공격의 위험을 초래할 수 있다.

### 적절한 설정의 중요성

cgroups 설정을 적절히 하지 않으면 한 컨테이너가 과도한 리소스를 사용하여 같은 호스트의 다른 컨테이너나 호스트 시스템 자체에 영향을 줄 수 있다. namespace만으로는 완전한 보안을 제공하지 못하며 추가적인 보안 계층이 필요하다.

## 보안 강화 방안

### 보안 모듈 사용

컨테이너 격리를 강화할 수 있는 한 영역은 AppArmor 및 SELinux와 같은 보안 모듈을 사용하는 것이다. 이러한 도구는 컨테이너 내부의 프로세스가 수행할 수 있는 작업에 대한 추가 제한을 시행한다.

namespace 및 cgroups와 결합하여 컨테이너 보안에 대한 심층 방어 접근 방식을 제공한다.

### User Namespace 활용

User namespace는 컨테이너 내부의 사용자 ID를 호스트의 다른 사용자 ID에 매핑하여 추가 보안 계층을 추가한다. 이는 컨테이너 내부에서 루트 사용자로 실행되는 프로세스가 호스트에서 루트 권한을 갖지 않음을 의미한다.

이 기능은 컨테이너 탈출 공격의 위험을 크게 줄인다.

### eBPF 기술

Edera에서 지원하는 eBPF는 안전한 샌드박스 프로그램이 Linux 커널 내부에서 실행될 수 있도록 허용한다. 이러한 프로그램은 시스템 호출을 관찰하고 보안 정책을 시행하며 사용자 공간 에이전트가 필요 없이 로그를 내보낼 수 있다.

### 현대적인 보안 접근 방식

2025-2026년에는 namespace와 cgroups가 필수적인 격리와 자원 관리를 제공하지만 조직은 고유한 한계를 해결하기 위해 계층화된 보안 접근 방식과 고급 런타임 시행 기술을 점점 더 채택하고 있다.

모범 사례는 다음과 같다.

- **리소스 제한 설정**: 적절한 CPU, 메모리, I/O 제한
- **Seccomp 프로파일**: 시스템 호출 필터링
- **Read-only 파일 시스템**: 변경 불가능한 컨테이너 환경
- **최소 권한 원칙**: 필요한 최소한의 권한만 부여

## 결론

Linux namespace는 2002년부터 시작되어 현재 8가지 유형으로 발전했으며 컨테이너 기술의 핵심 기반이 되었다. PID, Network, Mount, IPC, UTS, User, Cgroup namespace가 각각 프로세스, 네트워크, 파일 시스템, 프로세스 간 통신, 호스트 이름, 사용자 ID, cgroup 계층을 격리한다.

cgroups는 프로세스 그룹의 리소스를 할당하고 제한하는 기능을 제공한다. v1에서 v2로 발전하면서 통합 계층 구조를 도입하여 관리를 단순화했다. Kubernetes는 cgroup v1을 더 이상 사용하지 않으며 v2로의 전환이 진행 중이다.

Docker는 namespace와 cgroups를 추상화하여 사용자가 간단한 명령어로 컨테이너를 생성하고 관리할 수 있도록 한다. `docker run` 명령어 하나로 필요한 모든 격리 메커니즘이 자동으로 설정된다.

보안 측면에서 컨테이너는 동일한 커널을 공유하므로 완전한 격리를 제공하지 못한다. User namespace, AppArmor, SELinux, eBPF 등의 추가 보안 계층을 사용하여 방어 심층화 접근 방식을 구현해야 한다.

실제 환경에서는 적절한 리소스 제한 설정, 보안 프로파일 사용, 최소 권한 원칙 적용 등의 모범 사례를 따라 안전하고 효율적인 컨테이너 환경을 구축할 수 있다.
