---
title: "1차 캐시와 2차 캐시 알아보기"
date: 2024-06-08T03:39:05+09:00
tags: ["ORM", "java"]
description: "Hibernate 캐시 아키텍처의 역사와 발전, 1차 캐시의 동작 원리와 트랜잭션 범위, 2차 캐시의 공유 메커니즘과 동시성 제어, EhCache/Infinispan/Hazelcast 비교, 캐시 전략(READ_ONLY, READ_WRITE, NONSTRICT_READ_WRITE, TRANSACTIONAL), 분산 환경에서의 캐시 동기화 문제와 해결책까지 정리"
draft: false
---

## Hibernate 캐시의 역사와 발전

Hibernate는 초기부터 성능 최적화를 위한 캐싱 메커니즘을 제공해왔다.

### 1차 캐시의 등장

1차 캐시는 Hibernate의 초기 버전부터 영속성 컨텍스트의 핵심 기능으로 포함되어 있었다. 모든 JPA 구현체에서 필수적으로 제공해야 하는 기능이다.

1차 캐시는 JPA 사양의 일부로 EntityManager 또는 Session 수준에서 자동으로 활성화되며 비활성화할 수 없다. 트랜잭션 범위 내에서만 유효하여 데이터 일관성을 보장한다.

### 2차 캐시의 도입

2차 캐시는 Hibernate 2.x 버전부터 선택적 기능으로 도입되었다. JPA 2.0 사양에서 표준화되어 여러 구현체에서 일관된 방식으로 사용할 수 있게 되었다.

애플리케이션 전체에서 공유되는 캐시로 여러 트랜잭션과 세션 간에 데이터를 재사용할 수 있다. Hibernate는 2차 캐시 구현을 직접 제공하지 않고 표준 인터페이스를 통해 다양한 캐시 제공자를 플러그인 방식으로 통합할 수 있도록 설계되었다.

지원되는 캐시 제공자는 다음과 같다.

- **EhCache**: 가장 널리 사용되는 캐시 라이브러리
- **Infinispan**: Red Hat의 분산 캐시 솔루션
- **Hazelcast**: 클라우드 환경에 최적화된 인메모리 데이터 그리드

## 1차 캐시의 개념과 동작 원리

1차 캐시(First Level Cache)는 영속성 컨텍스트(Persistence Context) 내부에 존재하는 캐시를 말한다. 엔티티를 조회하면 영속성 컨텍스트가 엔티티를 캐시에 저장한다.

### 1차 캐시의 구조

1차 캐시는 Session 또는 EntityManager 수준에서 작동하며, 각 세션은 자체 1차 캐시를 가지고 있다. 이 캐시는 Key-Value 구조로 되어 있으며 엔티티의 식별자를 키로 사용하여 엔티티 인스턴스를 값으로 저장한다.

### 조회 메커니즘

엔티티를 조회할 때 Hibernate는 먼저 1차 캐시를 확인한다. 캐시에 엔티티가 있으면 데이터베이스를 조회하지 않고 캐시된 인스턴스를 반환한다.

이를 통해 같은 트랜잭션 내에서 동일한 엔티티를 여러 번 조회해도 데이터베이스 접근은 한 번만 발생한다. 성능을 크게 향상시키는 핵심 메커니즘이다.

### 트랜잭션 범위와 생명주기

1차 캐시는 트랜잭션 내에서만 유효하며 트랜잭션이 종료되면 1차 캐시도 함께 종료된다. 이는 트랜잭션 범위의 일관성을 보장하고 다른 트랜잭션의 변경 사항과 격리되도록 한다.

### 필수 기능

1차 캐시는 항상 활성화되어 있으며 비활성화할 수 없다. JPA와 Hibernate의 핵심 기능으로 영속성 컨텍스트 자체가 본질적으로 1차 캐시이다.

엔티티의 동일성(identity)을 보장하여 같은 영속성 컨텍스트 내에서 동일한 식별자를 가진 엔티티는 항상 같은 인스턴스를 반환한다.

## 더티 체킹과 1차 캐시의 관계

더티 체킹(Dirty Checking)은 1차 캐시를 통해 엔티티의 변경 사항을 추적하는 방식이다. 엔티티를 조회하면 영속성 컨텍스트는 엔티티의 초기 상태를 스냅샷으로 저장한다.

### 스냅샷 저장 메커니즘

Hibernate는 엔티티를 1차 캐시에 저장할 때 해당 엔티티의 복사본(스냅샷)을 함께 저장한다. flush가 발생할 때 현재 엔티티 상태와 스냅샷을 비교하여 변경된 필드를 감지한다.

변경이 감지되면 자동으로 UPDATE SQL을 생성하여 데이터베이스에 반영한다. 개발자가 명시적으로 update 메서드를 호출할 필요가 없다.

### 자동 동기화

엔티티의 상태가 변경되면 영속성 컨텍스트는 변경 사항을 추적하고 데이터베이스에 반영한다. 트랜잭션 커밋 시점에 자동으로 변경 사항이 데이터베이스에 동기화된다.

### 메모리 관리 주의사항

1차 캐시는 메모리에 저장되므로 조회 성능이 매우 빠르다. 그러나 트랜잭션이 길어질수록 메모리 사용량이 증가할 수 있다.

대량의 엔티티를 처리할 때는 주기적으로 flush()와 clear()를 호출하여 메모리를 관리해야 한다. 이를 통해 OutOfMemoryError를 방지할 수 있다.

## 2차 캐시의 개념과 공유 메커니즘

2차 캐시(Second Level Cache)는 여러 영속성 컨텍스트 간에 공유되는 캐시를 말한다. 영속성 컨텍스트가 종료되어도 캐시가 유지되고 여러 영속성 컨텍스트 간에 엔티티를 공유할 수 있다.

### 작동 범위와 공유

2차 캐시는 SessionFactory 또는 EntityManagerFactory 수준에서 작동하며 애플리케이션 전체에서 공유된다. 여러 트랜잭션과 여러 사용자 요청 간에 데이터를 재사용할 수 있어 데이터베이스 조회를 크게 줄일 수 있다.

### 생명주기와 적용 대상

2차 캐시는 여러 트랜잭션 간에 유효하다. 캐시된 데이터는 애플리케이션이 재시작될 때까지 또는 명시적으로 제거될 때까지 유지된다.

자주 읽히지만 드물게 변경되는 데이터에 적합하다.

- **코드 테이블**: 국가 코드, 통화 코드 등
- **설정 데이터**: 시스템 설정, 권한 정보 등
- **참조 데이터**: 카테고리, 부서 정보 등

### 활성화 방법

2차 캐시는 선택적 기능으로 기본적으로 비활성화되어 있다. 사용하려면 명시적으로 활성화하고 캐시 제공자를 설정해야 한다.

@Cacheable과 @Cache 애노테이션을 사용하여 엔티티별로 캐싱을 활성화할 수 있다.

### 동시성 제어

2차 캐시는 동시성 문제를 유발할 수 있으므로 객체를 직접 제공하는 것이 아니라 복사본을 제공하거나 락을 이용하여 동시성 문제를 제어해야 한다.

Hibernate는 엔티티를 직렬화하여 2차 캐시에 저장한다. 조회 시 역직렬화하여 새로운 인스턴스를 생성함으로써 캐시된 데이터의 변경이 다른 세션에 영향을 주지 않도록 한다.

## 2차 캐시 제공자 비교

Hibernate는 다양한 2차 캐시 제공자를 지원하며 각각 고유한 특징과 사용 사례를 가지고 있다.

### EhCache

Hibernate와 가장 널리 사용되는 조합으로 간단한 설정과 빠른 성능을 제공한다.

- **지원 모드**: 로컬 캐시와 분산 캐시 모두 지원
- **클러스터 환경**: Terracotta와 통합하여 사용 가능
- **표준 준수**: JCache(JSR-107) 표준을 구현하여 이식성이 높음

### Infinispan

Red Hat에서 개발한 오픈소스 데이터 그리드로 분산 캐싱에 최적화되어 있다.

- **확장성**: 클러스터 환경에서 뛰어난 확장성 제공
- **트랜잭션 지원**: 트랜잭션 캐시 전략을 완전히 지원
- **통합성**: Wildfly와 JBoss EAP에 기본 포함
- **동작 모드**: 복제(replication)와 분산(distribution) 모드를 모두 지원

### Hazelcast

인메모리 데이터 그리드로 간단한 설정과 자동 클러스터 발견 기능을 제공한다.

- **데이터 구조**: 분산 Map, Queue, Topic 등 다양한 데이터 구조 지원
- **클라우드 최적화**: 클라우드 환경에서 탁월한 성능
- **Spring Boot 통합**: 매우 쉬운 통합

### Caffeine

Google Guava 캐시의 후속으로 개발된 고성능 로컬 캐시이다.

- **성능**: 단일 JVM 환경에서 최고의 성능 제공
- **기능**: 자동 만료, 크기 제한, 통계 수집 등
- **제한사항**: 분산 캐싱을 지원하지 않아 클러스터 환경에는 적합하지 않음

## 캐시 동시성 전략

Hibernate는 2차 캐시의 동시성 제어를 위해 네 가지 캐시 동시성 전략을 제공한다. 각 전략은 성능과 일관성 간의 트레이드오프를 나타낸다.

### READ_ONLY

절대 변경되지 않는 데이터에 사용하며 가장 높은 성능을 제공한다.

- **락 사용**: 락이 필요 없어 동시성 문제가 발생하지 않음
- **수정 시도**: 엔티티를 수정하려고 하면 예외 발생
- **적용 대상**: 코드 테이블이나 정적 참조 데이터

### READ_WRITE

읽기와 쓰기가 모두 발생하는 데이터에 사용하며 대부분의 일반적인 사용 사례에 적합하다.

- **동시성 제어**: soft lock을 사용하여 동시성을 제어
- **일관성 보장**: 엔티티가 수정될 때 캐시 항목을 무효화
- **제공자 지원**: EhCache, Infinispan, Hazelcast 모두 지원

### NONSTRICT_READ_WRITE

동시에 같은 엔티티를 수정할 가능성이 낮을 때 사용한다. 락을 사용하지 않아 성능이 더 좋다.

- **성능**: READ_WRITE보다 빠르지만 짧은 시간 동안 stale 데이터를 읽을 수 있음
- **적용 대상**: 업데이트 빈도가 낮고 stale 데이터를 일시적으로 허용할 수 있는 경우

### TRANSACTIONAL

완전한 트랜잭션 격리를 제공하며 가장 강력한 일관성을 보장한다.

- **트랜잭션 지원**: JTA 트랜잭션과 통합되어 2단계 커밋을 지원
- **성능**: 성능 오버헤드가 큼
- **제공자 제한**: Infinispan과 같은 트랜잭션 캐시 제공자만 지원
- **적용 환경**: 분산 트랜잭션이 필요한 엔터프라이즈 환경

## 2차 캐시 사용 방법과 설정

### 기본 활성화 설정

2차 캐시를 사용하려면 먼저 hibernate.properties 또는 application.properties에서 2차 캐시를 활성화해야 한다.

```properties
spring.jpa.properties.hibernate.cache.use_second_level_cache=true
```

캐시 제공자를 지정해야 한다.

### 엔티티 캐싱 활성화

엔티티에 @Cacheable 애노테이션을 사용하여 캐시를 활성화할 수 있다. @Cache 애노테이션을 사용하여 캐시의 동시성 전략과 리전 이름을 설정할 수 있다.

컬렉션과 연관관계도 @Cache를 사용하여 캐싱할 수 있다.

### 쿼리 캐시

쿼리 캐시를 사용하면 JPQL이나 Criteria 쿼리의 결과를 캐시할 수 있다.

```properties
spring.jpa.properties.hibernate.cache.use_query_cache=true
```

쿼리에 setCacheable(true)를 호출하여 사용한다. 쿼리 캐시는 결과 집합의 식별자 목록만 저장하고 실제 엔티티는 2차 캐시에서 가져온다.

### 캐시 리전 설정

캐시 리전을 사용하여 서로 다른 엔티티나 컬렉션에 대해 다른 캐시 설정을 적용할 수 있다.

리전별로 독립적으로 설정할 수 있는 항목은 다음과 같다.

- **만료 시간**: 캐시 데이터의 유효 시간
- **최대 크기**: 캐시에 저장할 수 있는 최대 항목 수
- **제거 정책**: LRU, LFU 등의 캐시 제거 알고리즘

ehcache.xml이나 infinispan.xml 같은 제공자별 설정 파일에서 세부 사항을 구성한다.

## 캐시 동작 방식과 조회 순서

엔티티를 조회할 때 Hibernate는 다단계 캐시 조회 과정을 거친다.

### 1단계: 1차 캐시 확인

영속성 컨텍스트는 먼저 1차 캐시에서 엔티티를 찾는다. 1차 캐시에 엔티티가 있으면 즉시 반환한다.

### 2단계: 2차 캐시 확인

1차 캐시에 엔티티가 없으면 2차 캐시를 확인한다. 2차 캐시에서 발견되면 엔티티를 역직렬화하여 1차 캐시에 저장한 후 반환한다.

이를 2차 캐시 히트라고 하며 데이터베이스 조회를 피할 수 있다.

### 3단계: 데이터베이스 조회

2차 캐시에도 엔티티가 없으면 데이터베이스에서 엔티티를 조회한다. 조회한 엔티티는 1차 캐시와 2차 캐시에 모두 저장된다.

엔티티는 직렬화되어 2차 캐시에 저장되고 다음 조회를 위해 준비된다.

### 엔티티 수정 시 동작

엔티티를 수정하면 영속성 컨텍스트는 1차 캐시의 엔티티를 갱신한다. 트랜잭션 커밋 시 데이터베이스와 2차 캐시를 모두 업데이트한다.

캐시 동시성 전략에 따라 2차 캐시 항목을 무효화하거나 업데이트한다.

### 캐시 유효 기간

- **1차 캐시**: 트랜잭션이 종료되기 전까지 유효
- **2차 캐시**: 영속성 컨텍스트가 종료되어도 유효하며, 명시적으로 제거하거나 만료될 때까지 유지

## 분산 환경에서의 캐시 동기화 문제

여러 서버 인스턴스가 실행되는 분산 환경에서는 2차 캐시 동기화가 중요한 문제가 된다. 한 서버에서 엔티티를 수정하면 다른 서버의 캐시가 무효화되어야 한다.

### 로컬 캐시의 문제점

로컬 캐시만 사용하면 서버 간 캐시 불일치가 발생할 수 있다. 한 서버에서 데이터를 업데이트해도 다른 서버는 오래된 캐시된 데이터를 계속 제공한다.

이는 데이터 일관성 문제를 일으킨다.

### 분산 캐시 제공자 사용

분산 캐시 제공자(Infinispan, Hazelcast)를 사용하면 클러스터의 모든 노드 간에 캐시를 동기화할 수 있다.

- **복제 모드**: 모든 노드가 전체 캐시의 복사본을 가짐
- **분산 모드**: 캐시 항목이 여러 노드에 분산되어 저장됨

### 캐시 무효화 메커니즘

Hibernate의 캐시 무효화 메커니즘은 엔티티가 수정되거나 삭제될 때 해당 캐시 항목을 무효화한다. 분산 캐시에서는 무효화 메시지가 모든 노드로 전파된다.

쿼리 캐시는 테이블이 업데이트되면 관련된 모든 쿼리 결과를 무효화해야 하므로 관리가 더 복잡하다.

### Eventual Consistency와 강한 일관성

캐시 동기화 지연으로 인해 짧은 시간 동안 노드 간 데이터 불일치가 발생할 수 있다. eventual consistency를 수용할 수 있는지 고려해야 한다.

강한 일관성이 필요한 경우 TRANSACTIONAL 전략이나 분산 락을 사용해야 한다.

## 캐시 사용 시 주의사항과 모범 사례

### 선택적 캐싱 적용

2차 캐시는 모든 엔티티에 적용하는 것이 아니라 읽기가 많고 쓰기가 적은 엔티티에만 선택적으로 적용해야 한다. 자주 변경되는 데이터를 캐싱하면 캐시 무효화 오버헤드가 이점보다 클 수 있다.

### 캐시 통계 모니터링

캐시 통계를 모니터링하여 성능을 추적해야 한다.

- **히트율**: 캐시에서 데이터를 찾은 비율
- **미스율**: 캐시에서 데이터를 찾지 못한 비율
- **제거 횟수**: 캐시 용량 초과로 항목이 제거된 횟수

Hibernate Statistics API를 사용하거나 캐시 제공자의 모니터링 도구를 활용한다. 낮은 히트율은 캐시 설정을 재검토해야 함을 나타낸다.

### 메모리 사용량 제한

메모리 사용량을 제한하기 위해 캐시 크기와 만료 정책을 적절히 설정해야 한다.

- **TTL(Time To Live)**: 캐시 항목의 최대 생존 시간
- **TTI(Time To Idle)**: 캐시 항목이 액세스되지 않은 최대 유휴 시간
- **제거 정책**: LRU(Least Recently Used)나 LFU(Least Frequently Used)

### 연관관계 캐싱 주의사항

연관관계 캐싱은 신중하게 사용해야 한다. 컬렉션 캐싱은 메모리를 많이 사용할 수 있다.

지연 로딩된 컬렉션을 캐싱하면 N+1 문제를 줄일 수 있지만 메모리 사용량을 주시해야 한다.

### 검증과 테스트

테스트 환경과 프로덕션 환경에서 캐시 동작을 검증해야 한다.

- 캐시가 예상대로 작동하는지 로그를 확인
- 동시성 시나리오에서 데이터 일관성을 테스트
- 부하 테스트를 통해 캐시의 성능 향상을 측정

## 결론

Hibernate는 1차 캐시와 2차 캐시라는 두 단계의 캐싱 메커니즘을 제공하여 데이터베이스 조회를 최소화하고 성능을 향상시킨다.

1차 캐시는 트랜잭션 내에서만 유효한 필수 기능으로 영속성 컨텍스트의 핵심이다. 엔티티의 동일성을 보장하고 더티 체킹을 가능하게 한다. 모든 JPA 구현체에서 자동으로 활성화되고 비활성화할 수 없다.

2차 캐시는 여러 트랜잭션 간에 유효한 선택적 기능으로 애플리케이션 전체에서 공유된다. EhCache, Infinispan, Hazelcast 같은 다양한 캐시 제공자를 지원한다. READ_ONLY, READ_WRITE, NONSTRICT_READ_WRITE, TRANSACTIONAL 네 가지 동시성 전략을 제공한다.

2차 캐시는 자주 읽히지만 드물게 변경되는 데이터에 적합하다. 분산 환경에서는 캐시 동기화 문제를 고려해야 한다. 적절한 모니터링과 테스트를 통해 캐시의 효과를 검증해야 한다.

1차 캐시와 2차 캐시를 적절히 조합하고 캐시 동시성 전략을 올바르게 선택하면 데이터베이스 부하를 크게 줄이고 애플리케이션 성능을 향상시킬 수 있다. 메모리 사용량과 데이터 일관성 사이의 균형을 맞추는 것이 중요하다.
