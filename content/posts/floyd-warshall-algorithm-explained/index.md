---
title: "플로이드-워셜(Floyd-Warshall) 알고리즘 알아보기"
date: 2024-06-17T19:29:50+09:00
tags: ["플로이드-워셜", "Floyd-Warshall", "알고리즘", "최단 경로"]
draft: false
description: "플로이드-워셜 알고리즘은 모든 정점 쌍 사이의 최단 경로를 찾는 동적 프로그래밍 기반 알고리즘이다. O(V^3) 시간 복잡도로 음수 가중치를 처리할 수 있으며 추이적 폐쇄 계산에도 활용된다."
---

## 플로이드-워셜 알고리즘

플로이드-워셜(Floyd-Warshall) 알고리즘은 그래프의 모든 정점 쌍 사이의 최단 경로를 찾는 알고리즘이다. 동적 프로그래밍 접근 방식을 사용하며 O(V^3)의 시간 복잡도를 가진다. 음수 가중치를 가진 간선을 처리할 수 있고 음수 사이클을 탐지할 수 있다. 다익스트라나 벨만-포드 알고리즘과 달리 모든 쌍의 최단 경로를 한 번에 계산한다.

### 알고리즘의 역사

플로이드-워셜 알고리즘은 1962년 Robert Floyd와 Stephen Warshall에 의해 독립적으로 발표되었다. Floyd는 이 알고리즘을 최단 경로 문제에 적용했고 Warshall은 추이적 폐쇄 문제에 적용했다. 흥미롭게도 Bernard Roy가 1959년에 이미 유사한 알고리즘을 발표했으나 널리 알려지지 않았다.

이 알고리즘은 동적 프로그래밍의 고전적인 예시로 그래프 이론과 최적화 이론의 발전에 큰 기여를 했다. 현대 컴퓨터 과학에서 네트워크 라우팅, 게임 이론, 데이터베이스 쿼리 최적화 등 다양한 분야에서 활용되고 있다.

### 알고리즘 동작 원리

플로이드-워셜 알고리즘은 모든 쌍 최단 경로(All-Pairs Shortest Path) 문제를 해결한다. 핵심 아이디어는 중간 정점을 순차적으로 거쳐가는 경로를 고려하는 것이다. 정점 k를 중간 정점으로 사용할 때 i에서 j로 가는 경로는 두 가지 경우가 있다.

첫째는 k를 거치지 않고 직접 가는 경로이고 둘째는 k를 거쳐서 가는 경로다. 알고리즘은 이 두 경로 중 더 짧은 것을 선택한다. 이 과정을 모든 정점에 대해 반복하면 최종적으로 모든 쌍의 최단 경로를 얻을 수 있다.

### 점화식

알고리즘의 핵심은 다음 점화식으로 표현된다.

```
D[i][j] = min(D[i][j], D[i][k] + D[k][j])
```

여기서 D[i][j]는 정점 i에서 정점 j로 가는 최단 거리를 의미한다. D[i][k] + D[k][j]는 정점 i에서 k를 거쳐 j로 가는 거리다. 이 점화식은 "k를 거쳐가는 것이 더 짧으면 갱신한다"는 의미를 담고 있다. 이는 최단 경로의 부분 경로도 최단 경로라는 최적 부분 구조의 성질을 활용한 것이다.

k를 1부터 n까지 순회하면서 모든 i와 j 쌍에 대해 이 비교를 수행한다. k가 증가할수록 더 많은 중간 정점을 고려하게 되므로 점진적으로 최적해에 도달한다. k=1일 때는 정점 1만을 중간 정점으로 고려하고 k=2일 때는 정점 1과 2를 중간 정점으로 고려하는 식으로 진행된다.

이 점화식의 정확성은 귀납법으로 증명할 수 있다. k-1 단계까지 올바른 결과를 얻었다면 k 단계에서도 올바른 결과를 얻는다. 기저 사례는 k=0일 때로 직접 연결된 간선의 가중치만을 고려한 초기 상태다.

### 동적 프로그래밍 접근

플로이드-워셜 알고리즘은 동적 프로그래밍의 세 가지 핵심 요소를 모두 갖추고 있다.

첫째, 최적 부분 구조(Optimal Substructure)를 가진다. i에서 j로 가는 최단 경로는 i에서 k로 가는 최단 경로와 k에서 j로 가는 최단 경로로 구성된다. 둘째, 중복 부분 문제(Overlapping Subproblems)가 존재한다. 여러 경로가 동일한 중간 정점을 공유하므로 같은 계산이 반복된다. 셋째, 부분 문제의 결과를 저장하고 재사용한다.

3중 루프의 의미는 명확하다. 가장 바깥 루프는 중간 정점 k를 선택하고 중간 루프는 시작 정점 i를 선택하며 가장 안쪽 루프는 도착 정점 j를 선택한다. 이 순서가 중요한 이유는 k번째 단계에서는 1부터 k까지의 정점만을 중간 정점으로 고려하기 때문이다.

### 순서

알고리즘은 다음 단계로 진행된다.

1. 2차원 배열 D를 초기화한다. 인접한 정점 사이는 간선의 가중치로 설정하고 연결되지 않은 정점 사이는 무한대로 설정한다. 자기 자신으로의 거리는 0으로 설정한다.

2. 3중 반복문을 사용하여 모든 정점을 탐색한다. 바깥 루프는 중간 정점 k를 1부터 n까지 순회한다.

3. 각 k에 대해 모든 i, j 쌍을 검사하며 점화식을 적용하여 최단 경로를 갱신한다.

4. 모든 반복이 끝나면 D[i][j]는 i에서 j로 가는 최단 거리를 담고 있다.

### 예제 코드

```cpp
#include <iostream>
#include <vector>
using std::cin;
using std::cout;
using std::min;
using std::vector;

#define INF 1000000000

int main()
{
    int n, m;
    cin >> n >> m;

    vector<vector<int>> graph(n + 1, vector<int>(n + 1, INF));

    for (int i = 1; i <= n; i++)
    {
        graph[i][i] = 0;
    }

    for (int i = 0; i < m; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        graph[a][b] = c;
    }

    for (int k = 1; k <= n; k++)
    {
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]);
            }
        }
    }

    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            if (graph[i][j] == INF)
            {
                cout << "INF ";
            }
            else
            {
                cout << graph[i][j] << ' ';
            }
        }
        cout << '\n';
    }

    return 0;
}
```

### 음수 가중치와 음수 사이클

플로이드-워셜 알고리즘의 중요한 특징은 음수 가중치를 가진 간선을 처리할 수 있다는 점이다. 다익스트라 알고리즘은 음수 가중치를 처리하지 못하지만 플로이드-워셜은 이를 정확하게 계산한다. 이는 동적 프로그래밍의 특성상 모든 가능한 경로를 체계적으로 탐색하기 때문이다.

하지만 음수 사이클이 존재하는 경우는 주의가 필요하다. 음수 사이클은 순환하는 경로의 가중치 합이 음수인 사이클이다. 이런 사이클이 존재하면 계속 순환할수록 거리가 짧아지므로 최단 경로가 정의되지 않는다. 예를 들어 A → B → C → A로 돌아오는 경로의 가중치 합이 -5라면 이 사이클을 반복할수록 거리는 -5, -10, -15로 계속 감소한다.

음수 사이클은 알고리즘 실행 후 대각선 원소를 검사하여 탐지할 수 있다. D[i][i] < 0인 경우가 있다면 i를 포함하는 음수 사이클이 존재한다는 의미다. 정상적인 경우 자기 자신으로 돌아오는 최단 거리는 항상 0이어야 한다. 이 성질을 이용하면 O(1) 시간에 음수 사이클의 존재를 판단할 수 있다.

음수 사이클이 있는 그래프에서는 사이클에 포함된 정점과 연결된 모든 정점 쌍의 최단 거리가 음의 무한대가 된다. 실용적으로는 음수 사이클을 탐지하면 해당 정보를 사용자에게 알려주거나 특별한 처리를 수행해야 한다. 금융 거래의 차익거래 탐지나 화폐 환율 그래프 분석에서 음수 사이클은 수익 기회를 의미하기도 한다.

### 시간 복잡도 분석

플로이드-워셜 알고리즘의 시간 복잡도는 O(V^3)이다. 여기서 V는 정점의 개수다. 3중 반복문의 각 루프가 V번씩 실행되므로 총 V * V * V = V^3번의 연산이 수행된다. 각 연산은 비교와 덧셈 그리고 최솟값 선택으로 구성되며 모두 상수 시간에 수행된다.

공간 복잡도는 O(V^2)다. V x V 크기의 2차원 배열이 필요하다. 경로를 복원하려면 추가로 V x V 크기의 배열이 더 필요하지만 여전히 O(V^2)다. 이는 간선의 개수와 무관하게 정점의 개수에만 의존한다는 특징이 있다.

이 복잡도는 정점의 개수가 작을 때는 효율적이다. V가 수백 개 이하인 경우 충분히 실용적이다. 하지만 V가 수천, 수만 개로 늘어나면 계산 시간이 급격히 증가한다. 예를 들어 V=100이면 100만 번, V=1000이면 10억 번, V=10000이면 1조 번의 연산이 필요하다. 현대 컴퓨터에서 V=500 정도까지는 1초 이내에 처리 가능하다.

따라서 대규모 그래프에서는 다른 알고리즘을 고려해야 한다. 단일 시작점 최단 경로만 필요하다면 다익스트라나 벨만-포드가 더 효율적이다. 희소 그래프에서는 간선의 개수 E가 V^2보다 훨씬 작으므로 E를 활용하는 알고리즘이 유리하다. 반대로 밀집 그래프에서 모든 쌍의 최단 경로가 필요하다면 플로이드-워셜이 가장 적합하다.

### 다른 알고리즘과 비교

최단 경로 알고리즘들은 각각 장단점이 있으므로 상황에 맞게 선택해야 한다.

다익스트라 알고리즘을 V번 실행하면 모든 쌍의 최단 경로를 구할 수 있다. 우선순위 큐를 사용하면 한 번 실행에 O(E log V)가 소요되므로 총 O(V * E log V)다. 밀집 그래프에서는 E가 V^2에 가까우므로 O(V^3 log V)가 되어 플로이드-워셜보다 느리다. 하지만 희소 그래프에서는 E가 훨씬 작으므로 다익스트라가 더 빠르다. 예를 들어 E = O(V)인 그래프에서는 O(V^2 log V)로 플로이드-워셜의 O(V^3)보다 훨씬 빠르다.

벨만-포드 알고리즘을 V번 실행하면 O(V^2 * E)가 된다. 밀집 그래프에서는 O(V^4)로 매우 느리다. 희소 그래프에서도 O(V^2 * E)는 대개 O(V^3)보다 크다. 벨만-포드의 장점은 음수 가중치를 처리하고 음수 사이클을 명확히 탐지한다는 점이다. 하지만 플로이드-워셜도 음수 가중치를 처리할 수 있으므로 벨만-포드를 여러 번 실행할 이유는 거의 없다.

플로이드-워셜을 사용해야 하는 경우는 다음과 같다. 첫째, 정점의 개수가 적고 모든 쌍의 최단 경로가 필요한 경우다. 둘째, 밀집 그래프에서 모든 쌍의 최단 경로가 필요한 경우다. 셋째, 구현이 단순하고 이해하기 쉬워야 하는 경우다. 넷째, 음수 가중치를 처리해야 하는 경우다.

### 실제 응용 사례

플로이드-워셜 알고리즘은 다양한 실제 문제에 활용된다.

추이적 폐쇄(Transitive Closure)는 가장 직접적인 응용이다. 그래프에서 정점 i에서 정점 j로 도달 가능한지 판단하는 문제다. 가중치를 무시하고 연결 여부만 확인하면 된다. 이는 데이터베이스의 관계 분석이나 네트워크의 연결성 분석에 사용된다.

네트워크 지름(Network Diameter) 계산도 중요한 응용이다. 모든 쌍의 최단 거리 중 최댓값이 네트워크의 지름이다. 이는 네트워크의 효율성을 평가하는 지표로 사용된다. 통신 네트워크나 소셜 네트워크 분석에서 활용된다.

경로 복원은 실용적인 요구사항이다. 최단 거리뿐만 아니라 실제 경로를 알아야 하는 경우가 많다. 이를 위해 중간 정점을 기록하는 별도의 배열을 유지한다. 경로 복원은 내비게이션이나 네트워크 라우팅에서 필수적이다.

도시 간 교통망 설계에서도 사용된다. 모든 도시 쌍 사이의 최단 경로를 계산하여 교통 인프라를 최적화할 수 있다. 물류 센터 배치나 통신망 설계에서도 유사하게 활용된다.

게임 개발에서는 AI 캐릭터의 경로 탐색에 활용된다. 게임 맵이 작은 경우 사전에 모든 쌍의 최단 경로를 계산해두면 런타임에 빠르게 경로를 찾을 수 있다.

### 경로 복원 예제

최단 거리뿐만 아니라 실제 경로를 알아야 하는 경우가 많다. 이를 위해서는 next 배열을 사용한다.

```cpp
#include <iostream>
#include <vector>
using std::cin;
using std::cout;
using std::min;
using std::vector;

#define INF 1000000000

void printPath(int i, int j, vector<vector<int>>& next)
{
    if (next[i][j] == -1)
    {
        cout << "경로 없음\n";
        return;
    }

    cout << i;
    while (i != j)
    {
        i = next[i][j];
        cout << " -> " << i;
    }
    cout << '\n';
}

int main()
{
    int n, m;
    cin >> n >> m;

    vector<vector<int>> graph(n + 1, vector<int>(n + 1, INF));
    vector<vector<int>> next(n + 1, vector<int>(n + 1, -1));

    for (int i = 1; i <= n; i++)
    {
        graph[i][i] = 0;
    }

    for (int i = 0; i < m; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        graph[a][b] = c;
        next[a][b] = b;
    }

    for (int k = 1; k <= n; k++)
    {
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= n; j++)
            {
                if (graph[i][k] + graph[k][j] < graph[i][j])
                {
                    graph[i][j] = graph[i][k] + graph[k][j];
                    next[i][j] = next[i][k];
                }
            }
        }
    }

    // 경로 출력 예시
    printPath(1, n, next);

    return 0;
}
```

next[i][j]는 i에서 j로 가는 최단 경로에서 i 다음에 방문하는 정점을 저장한다. 거리를 갱신할 때마다 next도 함께 갱신한다. 경로를 출력할 때는 next를 따라가며 모든 중간 정점을 나열한다.

### 최적화 기법

플로이드-워셜 알고리즘을 더 효율적으로 만드는 여러 기법이 있다.

공간 최적화는 제한된 메모리 환경에서 중요하다. 3차원 배열 대신 2차원 배열을 재사용하여 공간을 절약할 수 있다. k번째 단계에서 k-1번째 결과를 덮어쓰는 방식이다. 이는 점화식의 특성상 안전하게 수행할 수 있다.

병렬 처리는 성능 향상의 기회다. i와 j 루프는 서로 독립적이므로 병렬화할 수 있다. 각 k 단계에서 모든 i, j 쌍을 동시에 계산할 수 있다. GPU나 멀티코어 CPU를 활용하면 큰 속도 향상을 얻을 수 있다.

조기 종료 최적화도 가능하다. 만약 특정 단계에서 어떤 거리도 갱신되지 않으면 더 이상의 개선이 없으므로 종료할 수 있다. 하지만 이 검사 자체에도 비용이 들므로 항상 유리한 것은 아니다.

### 실전 팁

구현 시 주의해야 할 몇 가지 중요한 사항이 있다.

초기화는 정확해야 한다. 연결되지 않은 정점 사이는 INF로 설정하되 자기 자신으로의 거리는 반드시 0으로 설정해야 한다. 이를 잊으면 잘못된 결과가 나온다. 또한 같은 간선이 여러 번 주어질 때는 가장 작은 가중치를 선택해야 한다.

INF 값 선택도 중요하다. 너무 큰 값을 사용하면 덧셈 시 오버플로우가 발생할 수 있다. 안전한 방법은 INF + INF가 오버플로우하지 않도록 충분히 크면서도 절반 정도의 여유가 있는 값을 선택하는 것이다. 예를 들어 int 범위라면 1e9 정도가 적당하다.

음수 사이클 탐지는 알고리즘 실행 후 대각선을 검사하여 수행한다. D[i][i] < 0인 경우가 하나라도 있으면 음수 사이클이 존재한다. 이 경우 사용자에게 경고하거나 특별한 처리를 해야 한다.

유향 그래프와 무향 그래프를 구분해야 한다. 무향 그래프는 양방향 간선으로 표현하되 간선을 두 번 추가해야 한다. 유향 그래프는 주어진 방향대로만 간선을 추가한다.

경로 복원이 필요한 경우 처음부터 next 배열을 유지해야 한다. 나중에 추가하기는 어렵다. next 배열은 초기에 직접 연결된 정점으로 설정하고 거리 갱신 시 함께 갱신한다.

### 장점

플로이드-워셜 알고리즘은 여러 강점을 가진다.

-   모든 정점 쌍 사이의 최단 경로를 한 번에 계산한다. 여러 쿼리가 예상되는 경우 사전 계산으로 효율적이다.
-   음수 가중치를 가진 간선을 정확하게 처리할 수 있다. 다익스트라로는 불가능한 문제를 해결한다.
-   구현이 매우 간단하고 이해하기 쉽다. 3중 루프와 한 줄의 갱신 로직만으로 구현된다.
-   음수 사이클을 탐지할 수 있다. 이는 많은 실제 문제에서 중요한 기능이다.
-   추이적 폐쇄 등 다른 문제로 확장하기 쉽다. 알고리즘의 구조가 명확하여 변형이 용이하다.

### 단점

알고리즘의 한계도 명확하다.

-   O(V^3) 시간 복잡도로 인해 대규모 그래프에서는 비실용적이다. 정점이 수천 개를 넘으면 계산 시간이 급격히 증가한다.
-   단일 시작점 최단 경로만 필요한 경우 과도한 계산을 수행한다. 다익스트라 한 번 실행이 더 효율적이다.
-   O(V^2) 공간 복잡도로 메모리 사용량이 크다. 정점이 많으면 메모리 부족 문제가 발생할 수 있다.
-   음수 사이클이 존재하면 최단 경로를 계산할 수 없다. 사이클 탐지만 가능하고 올바른 거리는 구할 수 없다.
-   희소 그래프에서는 간선의 개수를 활용하는 알고리즘보다 비효율적이다. 존재하지 않는 간선까지 모두 검사하기 때문이다.

### 시간 복잡도

-   플로이드-워셜 알고리즘의 시간 복잡도는 O(V^3)이다. 이때 V는 정점의 개수다.
-   공간 복잡도는 O(V^2)다. 경로 복원을 위해 추가 배열을 사용하더라도 여전히 O(V^2)다.
-   정점의 개수가 수백 개 이하일 때 실용적이며 그 이상에서는 다른 알고리즘을 고려해야 한다.
